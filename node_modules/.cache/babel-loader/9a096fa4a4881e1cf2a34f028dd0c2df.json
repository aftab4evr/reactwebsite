{"ast":null,"code":"'use strict';\n\nvar libmime = require('libmime');\n\nvar libqp = require('libqp');\n\nvar libbase64 = require('libbase64');\n\nvar punycode = require('punycode');\n\nvar addressparser = require('addressparser');\n\nvar stream = require('stream');\n\nvar PassThrough = stream.PassThrough;\n\nvar fs = require('fs');\n\nvar fetch = require('nodemailer-fetch');\n\nvar crypto = require('crypto');\n\nvar os = require('os');\n\nmodule.exports = MimeNode;\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\n\nfunction MimeNode(contentType, options) {\n  this.nodeCounter = 0;\n  options = options || {};\n  /**\n   * shared part of the unique multipart boundary\n   */\n\n  this.baseBoundary = options.baseBoundary || Date.now().toString() + Math.random();\n  this.boundaryPrefix = options.boundaryPrefix || '----sinikael';\n  this.disableFileAccess = !!options.disableFileAccess;\n  this.disableUrlAccess = !!options.disableUrlAccess;\n  /**\n   * If date headers is missing and current node is the root, this value is used instead\n   */\n\n  this.date = new Date();\n  /**\n   * Root node for current mime tree\n   */\n\n  this.rootNode = options.rootNode || this;\n  /**\n   * If true include Bcc in generated headers (if available)\n   */\n\n  this.keepBcc = !!options.keepBcc;\n  /**\n   * If filename is specified but contentType is not (probably an attachment)\n   * detect the content type from filename extension\n   */\n\n  if (options.filename) {\n    /**\n     * Filename for this node. Useful with attachments\n     */\n    this.filename = options.filename;\n\n    if (!contentType) {\n      contentType = libmime.detectMimeType(this.filename.split('.').pop());\n    }\n  }\n  /**\n   * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n   */\n\n\n  this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n  /**\n   * Immediate parent for this node (or undefined if not set)\n   */\n\n  this.parentNode = options.parentNode;\n  /**\n   * Hostname for default message-id values\n   */\n\n  this.hostname = options.hostname;\n  /**\n   * An array for possible child nodes\n   */\n\n  this.childNodes = [];\n  /**\n   * Used for generating unique boundaries (prepended to the shared base)\n   */\n\n  this._nodeId = ++this.rootNode.nodeCounter;\n  /**\n   * A list of header values for this node in the form of [{key:'', value:''}]\n   */\n\n  this._headers = [];\n  /**\n   * True if the content only uses ASCII printable characters\n   * @type {Boolean}\n   */\n\n  this._isPlainText = false;\n  /**\n   * True if the content is plain text but has longer lines than allowed\n   * @type {Boolean}\n   */\n\n  this._hasLongLines = false;\n  /**\n   * If set, use instead this value for envelopes instead of generating one\n   * @type {Boolean}\n   */\n\n  this._envelope = false;\n  /**\n   * If set then use this value as the stream content instead of building it\n   * @type {String|Buffer|Stream}\n   */\n\n  this._raw = false;\n  /**\n   * Additional transform streams that the message will be piped before\n   * exposing by createReadStream\n   * @type {Array}\n   */\n\n  this._transforms = [];\n  /**\n   * If content type is set (or derived from the filename) add it to headers\n   */\n\n  if (contentType) {\n    this.setHeader('Content-Type', contentType);\n  }\n} /////// PUBLIC METHODS\n\n/**\n * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n *\n * @param {String} [contentType] Optional content type\n * @param {Object} [options] Optional options object\n * @return {Object} Created node object\n */\n\n\nMimeNode.prototype.createChild = function (contentType, options) {\n  if (!options && typeof contentType === 'object') {\n    options = contentType;\n    contentType = undefined;\n  }\n\n  var node = new MimeNode(contentType, options);\n  this.appendChild(node);\n  return node;\n};\n/**\n * Appends an existing node to the mime tree. Removes the node from an existing\n * tree if needed\n *\n * @param {Object} childNode node to be appended\n * @return {Object} Appended node object\n */\n\n\nMimeNode.prototype.appendChild = function (childNode) {\n  if (childNode.rootNode !== this.rootNode) {\n    childNode.rootNode = this.rootNode;\n    childNode._nodeId = ++this.rootNode.nodeCounter;\n  }\n\n  childNode.parentNode = this;\n  this.childNodes.push(childNode);\n  return childNode;\n};\n/**\n * Replaces current node with another node\n *\n * @param {Object} node Replacement node\n * @return {Object} Replacement node\n */\n\n\nMimeNode.prototype.replace = function (node) {\n  if (node === this) {\n    return this;\n  }\n\n  this.parentNode.childNodes.forEach(function (childNode, i) {\n    if (childNode === this) {\n      node.rootNode = this.rootNode;\n      node.parentNode = this.parentNode;\n      node._nodeId = this._nodeId;\n      this.rootNode = this;\n      this.parentNode = undefined;\n      node.parentNode.childNodes[i] = node;\n    }\n  }.bind(this));\n  return node;\n};\n/**\n * Removes current node from the mime tree\n *\n * @return {Object} removed node\n */\n\n\nMimeNode.prototype.remove = function () {\n  if (!this.parentNode) {\n    return this;\n  }\n\n  for (var i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n    if (this.parentNode.childNodes[i] === this) {\n      this.parentNode.childNodes.splice(i, 1);\n      this.parentNode = undefined;\n      this.rootNode = this;\n      return this;\n    }\n  }\n};\n/**\n * Sets a header value. If the value for selected key exists, it is overwritten.\n * You can set multiple values as well by using [{key:'', value:''}] or\n * {key: 'value'} as the first argument.\n *\n * @param {String|Array|Object} key Header key or a list of key value pairs\n * @param {String} value Header value\n * @return {Object} current node\n */\n\n\nMimeNode.prototype.setHeader = function (key, value) {\n  var added = false,\n      headerValue; // Allow setting multiple headers at once\n\n  if (!value && key && typeof key === 'object') {\n    // allow {key:'content-type', value: 'text/plain'}\n    if (key.key && 'value' in key) {\n      this.setHeader(key.key, key.value);\n    } // allow [{key:'content-type', value: 'text/plain'}]\n    else if (Array.isArray(key)) {\n        key.forEach(function (i) {\n          this.setHeader(i.key, i.value);\n        }.bind(this));\n      } // allow {'content-type': 'text/plain'}\n      else {\n          Object.keys(key).forEach(function (i) {\n            this.setHeader(i, key[i]);\n          }.bind(this));\n        }\n\n    return this;\n  }\n\n  key = this._normalizeHeaderKey(key);\n  headerValue = {\n    key: key,\n    value: value\n  }; // Check if the value exists and overwrite\n\n  for (var i = 0, len = this._headers.length; i < len; i++) {\n    if (this._headers[i].key === key) {\n      if (!added) {\n        // replace the first match\n        this._headers[i] = headerValue;\n        added = true;\n      } else {\n        // remove following matches\n        this._headers.splice(i, 1);\n\n        i--;\n        len--;\n      }\n    }\n  } // match not found, append the value\n\n\n  if (!added) {\n    this._headers.push(headerValue);\n  }\n\n  return this;\n};\n/**\n * Adds a header value. If the value for selected key exists, the value is appended\n * as a new field and old one is not touched.\n * You can set multiple values as well by using [{key:'', value:''}] or\n * {key: 'value'} as the first argument.\n *\n * @param {String|Array|Object} key Header key or a list of key value pairs\n * @param {String} value Header value\n * @return {Object} current node\n */\n\n\nMimeNode.prototype.addHeader = function (key, value) {\n  // Allow setting multiple headers at once\n  if (!value && key && typeof key === 'object') {\n    // allow {key:'content-type', value: 'text/plain'}\n    if (key.key && key.value) {\n      this.addHeader(key.key, key.value);\n    } // allow [{key:'content-type', value: 'text/plain'}]\n    else if (Array.isArray(key)) {\n        key.forEach(function (i) {\n          this.addHeader(i.key, i.value);\n        }.bind(this));\n      } // allow {'content-type': 'text/plain'}\n      else {\n          Object.keys(key).forEach(function (i) {\n            this.addHeader(i, key[i]);\n          }.bind(this));\n        }\n\n    return this;\n  } else if (Array.isArray(value)) {\n    value.forEach(function (val) {\n      this.addHeader(key, val);\n    }.bind(this));\n    return this;\n  }\n\n  this._headers.push({\n    key: this._normalizeHeaderKey(key),\n    value: value\n  });\n\n  return this;\n};\n/**\n * Retrieves the first mathcing value of a selected key\n *\n * @param {String} key Key to search for\n * @retun {String} Value for the key\n */\n\n\nMimeNode.prototype.getHeader = function (key) {\n  key = this._normalizeHeaderKey(key);\n\n  for (var i = 0, len = this._headers.length; i < len; i++) {\n    if (this._headers[i].key === key) {\n      return this._headers[i].value;\n    }\n  }\n};\n/**\n * Sets body content for current node. If the value is a string, charset is added automatically\n * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n * the charset yourself\n *\n * @param (String|Buffer) content Body content\n * @return {Object} current node\n */\n\n\nMimeNode.prototype.setContent = function (content) {\n  var _self = this;\n\n  this.content = content;\n\n  if (typeof this.content.pipe === 'function') {\n    // pre-stream handler. might be triggered if a stream is set as content\n    // and 'error' fires before anything is done with this stream\n    this._contentErrorHandler = function (err) {\n      _self.content.removeListener('error', _self._contentErrorHandler);\n\n      _self.content = err;\n    };\n\n    this.content.once('error', this._contentErrorHandler);\n  } else if (typeof this.content === 'string') {\n    this._isPlainText = libmime.isPlainText(this.content);\n\n    if (this._isPlainText && libmime.hasLongerLines(this.content, 76)) {\n      // If there are lines longer than 76 symbols/bytes do not use 7bit\n      this._hasLongLines = true;\n    }\n  }\n\n  return this;\n};\n\nMimeNode.prototype.build = function (callback) {\n  var stream = this.createReadStream();\n  var buf = [];\n  var buflen = 0;\n  var returned = false;\n  stream.on('readable', function () {\n    var chunk;\n\n    while ((chunk = stream.read()) !== null) {\n      buf.push(chunk);\n      buflen += chunk.length;\n    }\n  });\n  stream.once('error', function (err) {\n    if (returned) {\n      return;\n    }\n\n    returned = true;\n    return callback(err);\n  });\n  stream.once('end', function (chunk) {\n    if (returned) {\n      return;\n    }\n\n    returned = true;\n\n    if (chunk && chunk.length) {\n      buf.push(chunk);\n      buflen += chunk.length;\n    }\n\n    return callback(null, Buffer.concat(buf, buflen));\n  });\n};\n\nMimeNode.prototype.getTransferEncoding = function () {\n  var transferEncoding = false;\n  var contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n  if (this.content) {\n    transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n\n    if (!transferEncoding || ['base64', 'quoted-printable'].indexOf(transferEncoding) < 0) {\n      if (/^text\\//i.test(contentType)) {\n        // If there are no special symbols, no need to modify the text\n        if (this._isPlainText && !this._hasLongLines) {\n          transferEncoding = '7bit';\n        } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n          // detect preferred encoding for string value\n          transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n        } else {\n          // we can not check content for a stream, so either use preferred encoding or fallback to QP\n          transferEncoding = this.transferEncoding === 'B' ? 'base64' : 'quoted-printable';\n        }\n      } else if (!/^(multipart|message)\\//i.test(contentType)) {\n        transferEncoding = transferEncoding || 'base64';\n      }\n    }\n  }\n\n  return transferEncoding;\n};\n/**\n * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n *\n * @returns {String} Headers\n */\n\n\nMimeNode.prototype.buildHeaders = function () {\n  var _self = this;\n\n  var transferEncoding = this.getTransferEncoding();\n  var headers = [];\n\n  if (transferEncoding) {\n    this.setHeader('Content-Transfer-Encoding', transferEncoding);\n  }\n\n  if (this.filename && !this.getHeader('Content-Disposition')) {\n    this.setHeader('Content-Disposition', 'attachment');\n  } // Ensure mandatory header fields\n\n\n  if (this.rootNode === this) {\n    if (!this.getHeader('Date')) {\n      this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n    } // ensure that Message-Id is present\n\n\n    this.messageId();\n\n    if (!this.getHeader('MIME-Version')) {\n      this.setHeader('MIME-Version', '1.0');\n    }\n  }\n\n  this._headers.forEach(function (header) {\n    var key = header.key;\n    var value = header.value;\n    var structured;\n    var param;\n    var options = {};\n    var formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n    if (value && formattedHeaders.indexOf(key) < 0 && typeof value === 'object') {\n      Object.keys(value).forEach(function (key) {\n        if (key !== 'value') {\n          options[key] = value[key];\n        }\n      });\n      value = (value.value || '').toString();\n\n      if (!value.trim()) {\n        return;\n      }\n    }\n\n    if (options.prepared) {\n      // header value is\n      headers.push(key + ': ' + value);\n      return;\n    }\n\n    switch (header.key) {\n      case 'Content-Disposition':\n        structured = libmime.parseHeaderValue(value);\n\n        if (_self.filename) {\n          structured.params.filename = _self.filename;\n        }\n\n        value = libmime.buildHeaderValue(structured);\n        break;\n\n      case 'Content-Type':\n        structured = libmime.parseHeaderValue(value);\n\n        _self._handleContentType(structured);\n\n        if (structured.value.match(/^text\\/plain\\b/) && typeof _self.content === 'string' && /[\\u0080-\\uFFFF]/.test(_self.content)) {\n          structured.params.charset = 'utf-8';\n        }\n\n        value = libmime.buildHeaderValue(structured);\n\n        if (_self.filename) {\n          // add support for non-compliant clients like QQ webmail\n          // we can't build the value with buildHeaderValue as the value is non standard and\n          // would be converted to parameter continuation encoding that we do not want\n          param = this._encodeWords(_self.filename);\n\n          if (param !== _self.filename || /[\\s\"=;]/.test(param)) {\n            // include value in quotes if needed\n            param = '\"' + param + '\"';\n          }\n\n          value += '; name=' + param;\n        }\n\n        break;\n\n      case 'Bcc':\n        if (!_self.keepBcc) {\n          // skip BCC values\n          return;\n        }\n\n        break;\n    }\n\n    value = _self._encodeHeaderValue(key, value); // skip empty lines\n\n    if (!(value || '').toString().trim()) {\n      return;\n    }\n\n    headers.push(libmime.foldLines(key + ': ' + value, 76));\n  }.bind(this));\n\n  return headers.join('\\r\\n');\n};\n/**\n * Streams the rfc2822 message from the current node. If this is a root node,\n * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n *\n * @return {String} Compiled message\n */\n\n\nMimeNode.prototype.createReadStream = function (options) {\n  options = options || {};\n  var outputStream = new PassThrough(options);\n  var transform;\n  this.stream(outputStream, options, function (err) {\n    if (err) {\n      outputStream.emit('error', err);\n      return;\n    }\n\n    outputStream.end();\n  });\n\n  for (var i = 0, len = this._transforms.length; i < len; i++) {\n    transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n    outputStream.once('error', function (err) {\n      transform.emit('error', err);\n    });\n    outputStream = outputStream.pipe(transform);\n  }\n\n  return outputStream;\n};\n/**\n * Appends a transform stream object to the transforms list. Final output\n * is passed through this stream before exposing\n *\n * @param {Object} transform Read-Write stream\n */\n\n\nMimeNode.prototype.transform = function (transform) {\n  this._transforms.push(transform);\n};\n\nMimeNode.prototype.stream = function (outputStream, options, done) {\n  var _self = this;\n\n  var transferEncoding = this.getTransferEncoding();\n  var contentStream;\n  var localStream; // protect actual callback against multiple triggering\n\n  var returned = false;\n\n  var callback = function (err) {\n    if (returned) {\n      return;\n    }\n\n    returned = true;\n    done(err);\n  }; // pushes node content\n\n\n  function sendContent() {\n    if (_self.content) {\n      if (Object.prototype.toString.call(_self.content) === '[object Error]') {\n        // content is already errored\n        return callback(_self.content);\n      }\n\n      if (typeof _self.content.pipe === 'function') {\n        _self.content.removeListener('error', _self._contentErrorHandler);\n\n        _self._contentErrorHandler = function (err) {\n          return callback(err);\n        };\n\n        _self.content.once('error', _self._contentErrorHandler);\n      }\n\n      if (['quoted-printable', 'base64'].indexOf(transferEncoding) >= 0) {\n        contentStream = new (transferEncoding === 'base64' ? libbase64 : libqp).Encoder(options);\n        contentStream.pipe(outputStream, {\n          end: false\n        });\n        contentStream.once('end', finalize);\n        contentStream.once('error', function (err) {\n          return callback(err);\n        });\n        localStream = _self._getStream(_self.content);\n        localStream.pipe(contentStream);\n      } else {\n        // anything that is not QP or Base54 passes as-is\n        localStream = _self._getStream(_self.content);\n        localStream.pipe(outputStream, {\n          end: false\n        });\n        localStream.once('end', finalize);\n      }\n\n      localStream.once('error', function (err) {\n        return callback(err);\n      });\n      return;\n    } else {\n      return setImmediate(finalize);\n    }\n  } // for multipart nodes, push child nodes\n  // for content nodes end the stream\n\n\n  function finalize() {\n    var childId = 0;\n\n    var processChildNode = function () {\n      if (childId >= _self.childNodes.length) {\n        outputStream.write('\\r\\n--' + _self.boundary + '--\\r\\n');\n        return callback();\n      }\n\n      var child = _self.childNodes[childId++];\n      outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + _self.boundary + '\\r\\n');\n      child.stream(outputStream, options, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        setImmediate(processChildNode);\n      });\n    };\n\n    if (_self.multipart) {\n      setImmediate(processChildNode);\n    } else {\n      return callback();\n    }\n  }\n\n  if (this._raw) {\n    setImmediate(function () {\n      if (Object.prototype.toString.call(_self._raw) === '[object Error]') {\n        // content is already errored\n        return callback(_self._raw);\n      } // remove default error handler (if set)\n\n\n      if (typeof _self._raw.pipe === 'function') {\n        _self._raw.removeListener('error', _self._contentErrorHandler);\n      }\n\n      var raw = _self._getStream(_self._raw);\n\n      raw.pipe(outputStream, {\n        end: false\n      });\n      raw.on('error', function (err) {\n        outputStream.emit('error', err);\n      });\n      raw.on('end', finalize);\n    });\n  } else {\n    outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n    setImmediate(sendContent);\n  }\n};\n/**\n * Sets envelope to be used instead of the generated one\n *\n * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n */\n\n\nMimeNode.prototype.setEnvelope = function (envelope) {\n  var list;\n  this._envelope = {\n    from: false,\n    to: []\n  };\n\n  if (envelope.from) {\n    list = [];\n\n    this._convertAddresses(this._parseAddresses(envelope.from), list);\n\n    list = list.filter(function (address) {\n      return address && address.address;\n    });\n\n    if (list.length && list[0]) {\n      this._envelope.from = list[0].address;\n    }\n  }\n\n  ['to', 'cc', 'bcc'].forEach(function (key) {\n    if (envelope[key]) {\n      this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n    }\n  }.bind(this));\n  this._envelope.to = this._envelope.to.map(function (to) {\n    return to.address;\n  }).filter(function (address) {\n    return address;\n  });\n  return this;\n};\n/**\n * Generates and returns an object with parsed address fields\n *\n * @return {Object} Address object\n */\n\n\nMimeNode.prototype.getAddresses = function () {\n  var addresses = {};\n\n  this._headers.forEach(function (header) {\n    var key = header.key.toLowerCase();\n\n    if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].indexOf(key) >= 0) {\n      if (!Array.isArray(addresses[key])) {\n        addresses[key] = [];\n      }\n\n      this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n    }\n  }.bind(this));\n\n  return addresses;\n};\n/**\n * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n *\n * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n */\n\n\nMimeNode.prototype.getEnvelope = function () {\n  if (this._envelope) {\n    return this._envelope;\n  }\n\n  var envelope = {\n    from: false,\n    to: []\n  };\n\n  this._headers.forEach(function (header) {\n    var list = [];\n\n    if (header.key === 'From' || !envelope.from && ['Reply-To', 'Sender'].indexOf(header.key) >= 0) {\n      this._convertAddresses(this._parseAddresses(header.value), list);\n\n      if (list.length && list[0]) {\n        envelope.from = list[0].address;\n      }\n    } else if (['To', 'Cc', 'Bcc'].indexOf(header.key) >= 0) {\n      this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n    }\n  }.bind(this));\n\n  envelope.to = envelope.to.map(function (to) {\n    return to.address;\n  });\n  return envelope;\n};\n/**\n * Returns Message-Id value. If it does not exist, then creates one\n *\n * @return {String} Message-Id value\n */\n\n\nMimeNode.prototype.messageId = function () {\n  var messageId = this.getHeader('Message-ID'); // You really should define your own Message-Id field!\n\n  if (!messageId) {\n    messageId = this._generateMessageId();\n    this.setHeader('Message-ID', messageId);\n  }\n\n  return messageId;\n};\n/**\n * Sets pregenerated content that will be used as the output of this node\n *\n * @param {String|Buffer|Stream} Raw MIME contents\n */\n\n\nMimeNode.prototype.setRaw = function (raw) {\n  var _self = this;\n\n  this._raw = raw;\n\n  if (this._raw && typeof this._raw.pipe === 'function') {\n    // pre-stream handler. might be triggered if a stream is set as content\n    // and 'error' fires before anything is done with this stream\n    this._contentErrorHandler = function (err) {\n      _self._raw.removeListener('error', _self._contentErrorHandler);\n\n      _self._raw = err;\n    };\n\n    _self._raw.once('error', this._contentErrorHandler);\n  }\n\n  return this;\n}; /////// PRIVATE METHODS\n\n/**\n * Detects and returns handle to a stream related with the content.\n *\n * @param {Mixed} content Node content\n * @returns {Object} Stream object\n */\n\n\nMimeNode.prototype._getStream = function (content) {\n  var contentStream;\n\n  if (typeof content.pipe === 'function') {\n    // assume as stream\n    return content;\n  } else if (content && typeof content.path === 'string' && !content.href) {\n    if (this.disableFileAccess) {\n      contentStream = new PassThrough();\n      setImmediate(function () {\n        contentStream.emit('error', new Error('File access rejected for ' + content.path));\n      });\n      return contentStream;\n    } // read file\n\n\n    return fs.createReadStream(content.path);\n  } else if (content && typeof content.href === 'string') {\n    if (this.disableUrlAccess) {\n      contentStream = new PassThrough();\n      setImmediate(function () {\n        contentStream.emit('error', new Error('Url access rejected for ' + content.href));\n      });\n      return contentStream;\n    } // fetch URL\n\n\n    return fetch(content.href);\n  } else {\n    // pass string or buffer content as a stream\n    contentStream = new PassThrough();\n    setImmediate(function () {\n      contentStream.end(content || '');\n    });\n    return contentStream;\n  }\n};\n/**\n * Parses addresses. Takes in a single address or an array or an\n * array of address arrays (eg. To: [[first group], [second group],...])\n *\n * @param {Mixed} addresses Addresses to be parsed\n * @return {Array} An array of address objects\n */\n\n\nMimeNode.prototype._parseAddresses = function (addresses) {\n  return [].concat.apply([], [].concat(addresses).map(function (address) {\n    if (address && address.address) {\n      address = this._convertAddresses(address);\n    }\n\n    return addressparser(address);\n  }.bind(this)));\n};\n/**\n * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n *\n * @param {String} key Key to be normalized\n * @return {String} key in Camel-Case form\n */\n\n\nMimeNode.prototype._normalizeHeaderKey = function (key) {\n  return (key || '').toString(). // no newlines in keys\n  replace(/\\r?\\n|\\r/g, ' ').trim().toLowerCase(). // use uppercase words, except MIME\n  replace(/^X\\-SMTPAPI$|^(MIME|DKIM)\\b|^[a-z]|\\-(SPF|FBL|ID|MD5)$|\\-[a-z]/ig, function (c) {\n    return c.toUpperCase();\n  }). // special case\n  replace(/^Content\\-Features$/i, 'Content-features');\n};\n/**\n * Checks if the content type is multipart and defines boundary if needed.\n * Doesn't return anything, modifies object argument instead.\n *\n * @param {Object} structured Parsed header value for 'Content-Type' key\n */\n\n\nMimeNode.prototype._handleContentType = function (structured) {\n  this.contentType = structured.value.trim().toLowerCase();\n  this.multipart = this.contentType.split('/').reduce(function (prev, value) {\n    return prev === 'multipart' ? value : false;\n  });\n\n  if (this.multipart) {\n    this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n  } else {\n    this.boundary = false;\n  }\n};\n/**\n * Generates a multipart boundary value\n *\n * @return {String} boundary value\n */\n\n\nMimeNode.prototype._generateBoundary = function () {\n  return this.rootNode.boundaryPrefix + '-?=_' + this._nodeId + '-' + this.rootNode.baseBoundary;\n};\n/**\n * Encodes a header value for use in the generated rfc2822 email.\n *\n * @param {String} key Header key\n * @param {String} value Header value\n */\n\n\nMimeNode.prototype._encodeHeaderValue = function (key, value) {\n  key = this._normalizeHeaderKey(key);\n\n  switch (key) {\n    // Structured headers\n    case 'From':\n    case 'Sender':\n    case 'To':\n    case 'Cc':\n    case 'Bcc':\n    case 'Reply-To':\n      return this._convertAddresses(this._parseAddresses(value));\n    // values enclosed in <>\n\n    case 'Message-ID':\n    case 'In-Reply-To':\n    case 'Content-Id':\n      value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n      if (value.charAt(0) !== '<') {\n        value = '<' + value;\n      }\n\n      if (value.charAt(value.length - 1) !== '>') {\n        value = value + '>';\n      }\n\n      return value;\n    // space separated list of values enclosed in <>\n\n    case 'References':\n      value = [].concat.apply([], [].concat(value || '').map(function (elm) {\n        elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n        return elm.replace(/<[^>]*>/g, function (str) {\n          return str.replace(/\\s/g, '');\n        }).split(/\\s+/);\n      })).map(function (elm) {\n        if (elm.charAt(0) !== '<') {\n          elm = '<' + elm;\n        }\n\n        if (elm.charAt(elm.length - 1) !== '>') {\n          elm = elm + '>';\n        }\n\n        return elm;\n      });\n      return value.join(' ').trim();\n\n    case 'Date':\n      if (Object.prototype.toString.call(value) === '[object Date]') {\n        return value.toUTCString().replace(/GMT/, '+0000');\n      }\n\n      value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n      return this._encodeWords(value);\n\n    default:\n      value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' '); // encodeWords only encodes if needed, otherwise the original string is returned\n\n      return this._encodeWords(value);\n  }\n};\n/**\n * Rebuilds address object using punycode and other adjustments\n *\n * @param {Array} addresses An array of address objects\n * @param {Array} [uniqueList] An array to be populated with addresses\n * @return {String} address string\n */\n\n\nMimeNode.prototype._convertAddresses = function (addresses, uniqueList) {\n  var values = [];\n  uniqueList = uniqueList || [];\n  [].concat(addresses || []).forEach(function (address) {\n    if (address.address) {\n      address.address = address.address.replace(/@.+$/, function (domain) {\n        // usernames are not touched and are kept as is even if these include unicode\n        // domains are punycoded by default\n        // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n        // non-unicode domains are left as is\n        return '@' + punycode.toASCII(domain.substr(1));\n      });\n\n      if (!address.name) {\n        values.push(address.address);\n      } else if (address.name) {\n        values.push(this._encodeAddressName(address.name) + ' <' + address.address + '>');\n      }\n\n      if (address.address) {\n        if (!uniqueList.filter(function (a) {\n          return a.address === address.address;\n        }).length) {\n          uniqueList.push(address);\n        }\n      }\n    } else if (address.group) {\n      values.push(this._encodeAddressName(address.name) + ':' + (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim() + ';');\n    }\n  }.bind(this));\n  return values.join(', ');\n};\n/**\n * If needed, mime encodes the name part\n *\n * @param {String} name Name part of an address\n * @returns {String} Mime word encoded string if needed\n */\n\n\nMimeNode.prototype._encodeAddressName = function (name) {\n  if (!/^[\\w ']*$/.test(name)) {\n    if (/^[\\x20-\\x7e]*$/.test(name)) {\n      return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n    } else {\n      return libmime.encodeWord(name, this._getTextEncoding(name), 52);\n    }\n  }\n\n  return name;\n};\n/**\n * If needed, mime encodes the name part\n *\n * @param {String} name Name part of an address\n * @returns {String} Mime word encoded string if needed\n */\n\n\nMimeNode.prototype._encodeWords = function (value) {\n  return libmime.encodeWords(value, this._getTextEncoding(value), 52);\n};\n/**\n * Detects best mime encoding for a text value\n *\n * @param {String} value Value to check for\n * @return {String} either 'Q' or 'B'\n */\n\n\nMimeNode.prototype._getTextEncoding = function (value) {\n  value = (value || '').toString();\n  var encoding = this.textEncoding;\n  var latinLen;\n  var nonLatinLen;\n\n  if (!encoding) {\n    // count latin alphabet symbols and 8-bit range symbols + control symbols\n    // if there are more latin characters, then use quoted-printable\n    // encoding, otherwise use base64\n    nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length;\n    latinLen = (value.match(/[a-z]/gi) || []).length; // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n\n    encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n  }\n\n  return encoding;\n};\n/**\n * Generates a message id\n *\n * @return {String} Random Message-ID value\n */\n\n\nMimeNode.prototype._generateMessageId = function () {\n  return '<' + [2, 2, 2, 6].reduce( // crux to generate UUID-like random strings\n  function (prev, len) {\n    return prev + '-' + crypto.randomBytes(len).toString('hex');\n  }, crypto.randomBytes(4).toString('hex')) + '@' + // try to use the domain of the FROM address or fallback to server hostname\n  (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() + '>';\n};","map":{"version":3,"sources":["/Users/aftab/Desktop/React/reactlivewebsite-master/node_modules/buildmail/lib/buildmail.js"],"names":["libmime","require","libqp","libbase64","punycode","addressparser","stream","PassThrough","fs","fetch","crypto","os","module","exports","MimeNode","contentType","options","nodeCounter","baseBoundary","Date","now","toString","Math","random","boundaryPrefix","disableFileAccess","disableUrlAccess","date","rootNode","keepBcc","filename","detectMimeType","split","pop","textEncoding","trim","charAt","toUpperCase","parentNode","hostname","childNodes","_nodeId","_headers","_isPlainText","_hasLongLines","_envelope","_raw","_transforms","setHeader","prototype","createChild","undefined","node","appendChild","childNode","push","replace","forEach","i","bind","remove","length","splice","key","value","added","headerValue","Array","isArray","Object","keys","_normalizeHeaderKey","len","addHeader","val","getHeader","setContent","content","_self","pipe","_contentErrorHandler","err","removeListener","once","isPlainText","hasLongerLines","build","callback","createReadStream","buf","buflen","returned","on","chunk","read","Buffer","concat","getTransferEncoding","transferEncoding","toLowerCase","indexOf","test","_getTextEncoding","buildHeaders","headers","toUTCString","messageId","header","structured","param","formattedHeaders","prepared","parseHeaderValue","params","buildHeaderValue","_handleContentType","match","charset","_encodeWords","_encodeHeaderValue","foldLines","join","outputStream","transform","emit","end","done","contentStream","localStream","sendContent","call","Encoder","finalize","_getStream","setImmediate","childId","processChildNode","write","boundary","child","multipart","raw","setEnvelope","envelope","list","from","to","_convertAddresses","_parseAddresses","filter","address","map","getAddresses","addresses","getEnvelope","_generateMessageId","setRaw","path","href","Error","apply","c","reduce","prev","_generateBoundary","elm","str","uniqueList","values","domain","toASCII","substr","name","_encodeAddressName","a","group","encodeWord","encodeWords","encoding","latinLen","nonLatinLen","randomBytes"],"mappings":"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","sourcesContent":["'use strict';\n\nvar libmime = require('libmime');\nvar libqp = require('libqp');\nvar libbase64 = require('libbase64');\nvar punycode = require('punycode');\nvar addressparser = require('addressparser');\nvar stream = require('stream');\nvar PassThrough = stream.PassThrough;\nvar fs = require('fs');\nvar fetch = require('nodemailer-fetch');\nvar crypto = require('crypto');\nvar os = require('os');\n\nmodule.exports = MimeNode;\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nfunction MimeNode(contentType, options) {\n    this.nodeCounter = 0;\n\n    options = options || {};\n\n    /**\n     * shared part of the unique multipart boundary\n     */\n    this.baseBoundary = options.baseBoundary || Date.now().toString() + Math.random();\n    this.boundaryPrefix = options.boundaryPrefix || '----sinikael';\n\n    this.disableFileAccess = !!options.disableFileAccess;\n    this.disableUrlAccess = !!options.disableUrlAccess;\n\n    /**\n     * If date headers is missing and current node is the root, this value is used instead\n     */\n    this.date = new Date();\n\n    /**\n     * Root node for current mime tree\n     */\n    this.rootNode = options.rootNode || this;\n\n    /**\n     * If true include Bcc in generated headers (if available)\n     */\n    this.keepBcc = !!options.keepBcc;\n\n    /**\n     * If filename is specified but contentType is not (probably an attachment)\n     * detect the content type from filename extension\n     */\n    if (options.filename) {\n        /**\n         * Filename for this node. Useful with attachments\n         */\n        this.filename = options.filename;\n        if (!contentType) {\n            contentType = libmime.detectMimeType(this.filename.split('.').pop());\n        }\n    }\n\n    /**\n     * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n     */\n    this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n    /**\n     * Immediate parent for this node (or undefined if not set)\n     */\n    this.parentNode = options.parentNode;\n\n    /**\n     * Hostname for default message-id values\n     */\n    this.hostname = options.hostname;\n\n    /**\n     * An array for possible child nodes\n     */\n    this.childNodes = [];\n\n    /**\n     * Used for generating unique boundaries (prepended to the shared base)\n     */\n    this._nodeId = ++this.rootNode.nodeCounter;\n\n    /**\n     * A list of header values for this node in the form of [{key:'', value:''}]\n     */\n    this._headers = [];\n\n    /**\n     * True if the content only uses ASCII printable characters\n     * @type {Boolean}\n     */\n    this._isPlainText = false;\n\n    /**\n     * True if the content is plain text but has longer lines than allowed\n     * @type {Boolean}\n     */\n    this._hasLongLines = false;\n\n    /**\n     * If set, use instead this value for envelopes instead of generating one\n     * @type {Boolean}\n     */\n    this._envelope = false;\n\n    /**\n     * If set then use this value as the stream content instead of building it\n     * @type {String|Buffer|Stream}\n     */\n    this._raw = false;\n\n    /**\n     * Additional transform streams that the message will be piped before\n     * exposing by createReadStream\n     * @type {Array}\n     */\n    this._transforms = [];\n\n    /**\n     * If content type is set (or derived from the filename) add it to headers\n     */\n    if (contentType) {\n        this.setHeader('Content-Type', contentType);\n    }\n}\n\n/////// PUBLIC METHODS\n\n/**\n * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n *\n * @param {String} [contentType] Optional content type\n * @param {Object} [options] Optional options object\n * @return {Object} Created node object\n */\nMimeNode.prototype.createChild = function (contentType, options) {\n    if (!options && typeof contentType === 'object') {\n        options = contentType;\n        contentType = undefined;\n    }\n    var node = new MimeNode(contentType, options);\n    this.appendChild(node);\n    return node;\n};\n\n/**\n * Appends an existing node to the mime tree. Removes the node from an existing\n * tree if needed\n *\n * @param {Object} childNode node to be appended\n * @return {Object} Appended node object\n */\nMimeNode.prototype.appendChild = function (childNode) {\n\n    if (childNode.rootNode !== this.rootNode) {\n        childNode.rootNode = this.rootNode;\n        childNode._nodeId = ++this.rootNode.nodeCounter;\n    }\n\n    childNode.parentNode = this;\n\n    this.childNodes.push(childNode);\n    return childNode;\n};\n\n/**\n * Replaces current node with another node\n *\n * @param {Object} node Replacement node\n * @return {Object} Replacement node\n */\nMimeNode.prototype.replace = function (node) {\n    if (node === this) {\n        return this;\n    }\n\n    this.parentNode.childNodes.forEach(function (childNode, i) {\n        if (childNode === this) {\n\n            node.rootNode = this.rootNode;\n            node.parentNode = this.parentNode;\n            node._nodeId = this._nodeId;\n\n            this.rootNode = this;\n            this.parentNode = undefined;\n\n            node.parentNode.childNodes[i] = node;\n        }\n    }.bind(this));\n\n    return node;\n};\n\n/**\n * Removes current node from the mime tree\n *\n * @return {Object} removed node\n */\nMimeNode.prototype.remove = function () {\n    if (!this.parentNode) {\n        return this;\n    }\n\n    for (var i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n        if (this.parentNode.childNodes[i] === this) {\n            this.parentNode.childNodes.splice(i, 1);\n            this.parentNode = undefined;\n            this.rootNode = this;\n            return this;\n        }\n    }\n};\n\n/**\n * Sets a header value. If the value for selected key exists, it is overwritten.\n * You can set multiple values as well by using [{key:'', value:''}] or\n * {key: 'value'} as the first argument.\n *\n * @param {String|Array|Object} key Header key or a list of key value pairs\n * @param {String} value Header value\n * @return {Object} current node\n */\nMimeNode.prototype.setHeader = function (key, value) {\n    var added = false,\n        headerValue;\n\n    // Allow setting multiple headers at once\n    if (!value && key && typeof key === 'object') {\n        // allow {key:'content-type', value: 'text/plain'}\n        if (key.key && 'value' in key) {\n            this.setHeader(key.key, key.value);\n        }\n        // allow [{key:'content-type', value: 'text/plain'}]\n        else if (Array.isArray(key)) {\n            key.forEach(function (i) {\n                this.setHeader(i.key, i.value);\n            }.bind(this));\n        }\n        // allow {'content-type': 'text/plain'}\n        else {\n            Object.keys(key).forEach(function (i) {\n                this.setHeader(i, key[i]);\n            }.bind(this));\n        }\n        return this;\n    }\n\n    key = this._normalizeHeaderKey(key);\n\n    headerValue = {\n        key: key,\n        value: value\n    };\n\n    // Check if the value exists and overwrite\n    for (var i = 0, len = this._headers.length; i < len; i++) {\n        if (this._headers[i].key === key) {\n            if (!added) {\n                // replace the first match\n                this._headers[i] = headerValue;\n                added = true;\n            } else {\n                // remove following matches\n                this._headers.splice(i, 1);\n                i--;\n                len--;\n            }\n        }\n    }\n\n    // match not found, append the value\n    if (!added) {\n        this._headers.push(headerValue);\n    }\n\n    return this;\n};\n\n/**\n * Adds a header value. If the value for selected key exists, the value is appended\n * as a new field and old one is not touched.\n * You can set multiple values as well by using [{key:'', value:''}] or\n * {key: 'value'} as the first argument.\n *\n * @param {String|Array|Object} key Header key or a list of key value pairs\n * @param {String} value Header value\n * @return {Object} current node\n */\nMimeNode.prototype.addHeader = function (key, value) {\n\n    // Allow setting multiple headers at once\n    if (!value && key && typeof key === 'object') {\n        // allow {key:'content-type', value: 'text/plain'}\n        if (key.key && key.value) {\n            this.addHeader(key.key, key.value);\n        }\n        // allow [{key:'content-type', value: 'text/plain'}]\n        else if (Array.isArray(key)) {\n            key.forEach(function (i) {\n                this.addHeader(i.key, i.value);\n            }.bind(this));\n        }\n        // allow {'content-type': 'text/plain'}\n        else {\n            Object.keys(key).forEach(function (i) {\n                this.addHeader(i, key[i]);\n            }.bind(this));\n        }\n        return this;\n    } else if (Array.isArray(value)) {\n        value.forEach(function (val) {\n            this.addHeader(key, val);\n        }.bind(this));\n        return this;\n    }\n\n    this._headers.push({\n        key: this._normalizeHeaderKey(key),\n        value: value\n    });\n\n    return this;\n};\n\n/**\n * Retrieves the first mathcing value of a selected key\n *\n * @param {String} key Key to search for\n * @retun {String} Value for the key\n */\nMimeNode.prototype.getHeader = function (key) {\n    key = this._normalizeHeaderKey(key);\n    for (var i = 0, len = this._headers.length; i < len; i++) {\n        if (this._headers[i].key === key) {\n            return this._headers[i].value;\n        }\n    }\n};\n\n/**\n * Sets body content for current node. If the value is a string, charset is added automatically\n * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n * the charset yourself\n *\n * @param (String|Buffer) content Body content\n * @return {Object} current node\n */\nMimeNode.prototype.setContent = function (content) {\n    var _self = this;\n    this.content = content;\n    if (typeof this.content.pipe === 'function') {\n        // pre-stream handler. might be triggered if a stream is set as content\n        // and 'error' fires before anything is done with this stream\n        this._contentErrorHandler = function (err) {\n            _self.content.removeListener('error', _self._contentErrorHandler);\n            _self.content = err;\n        };\n        this.content.once('error', this._contentErrorHandler);\n    } else if (typeof this.content === 'string') {\n        this._isPlainText = libmime.isPlainText(this.content);\n        if (this._isPlainText && libmime.hasLongerLines(this.content, 76)) {\n            // If there are lines longer than 76 symbols/bytes do not use 7bit\n            this._hasLongLines = true;\n        }\n    }\n    return this;\n};\n\nMimeNode.prototype.build = function (callback) {\n    var stream = this.createReadStream();\n    var buf = [];\n    var buflen = 0;\n    var returned = false;\n\n    stream.on('readable', function () {\n        var chunk;\n\n        while ((chunk = stream.read()) !== null) {\n            buf.push(chunk);\n            buflen += chunk.length;\n        }\n    });\n\n    stream.once('error', function (err) {\n        if (returned) {\n            return;\n        }\n        returned = true;\n\n        return callback(err);\n    });\n\n    stream.once('end', function (chunk) {\n        if (returned) {\n            return;\n        }\n        returned = true;\n\n        if (chunk && chunk.length) {\n            buf.push(chunk);\n            buflen += chunk.length;\n        }\n        return callback(null, Buffer.concat(buf, buflen));\n    });\n};\n\nMimeNode.prototype.getTransferEncoding = function () {\n    var transferEncoding = false;\n    var contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n    if (this.content) {\n        transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n        if (!transferEncoding || ['base64', 'quoted-printable'].indexOf(transferEncoding) < 0) {\n            if (/^text\\//i.test(contentType)) {\n                // If there are no special symbols, no need to modify the text\n                if (this._isPlainText && !this._hasLongLines) {\n                    transferEncoding = '7bit';\n                } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n                    // detect preferred encoding for string value\n                    transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n                } else {\n                    // we can not check content for a stream, so either use preferred encoding or fallback to QP\n                    transferEncoding = this.transferEncoding === 'B' ? 'base64' : 'quoted-printable';\n                }\n            } else if (!/^(multipart|message)\\//i.test(contentType)) {\n                transferEncoding = transferEncoding || 'base64';\n            }\n        }\n    }\n    return transferEncoding;\n};\n\n/**\n * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n *\n * @returns {String} Headers\n */\nMimeNode.prototype.buildHeaders = function () {\n    var _self = this;\n    var transferEncoding = this.getTransferEncoding();\n    var headers = [];\n\n    if (transferEncoding) {\n        this.setHeader('Content-Transfer-Encoding', transferEncoding);\n    }\n\n    if (this.filename && !this.getHeader('Content-Disposition')) {\n        this.setHeader('Content-Disposition', 'attachment');\n    }\n\n    // Ensure mandatory header fields\n    if (this.rootNode === this) {\n        if (!this.getHeader('Date')) {\n            this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n        }\n\n        // ensure that Message-Id is present\n        this.messageId();\n\n        if (!this.getHeader('MIME-Version')) {\n            this.setHeader('MIME-Version', '1.0');\n        }\n    }\n\n    this._headers.forEach(function (header) {\n        var key = header.key;\n        var value = header.value;\n        var structured;\n        var param;\n        var options = {};\n        var formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n        if (value && formattedHeaders.indexOf(key) < 0 && typeof value === 'object') {\n            Object.keys(value).forEach(function (key) {\n                if (key !== 'value') {\n                    options[key] = value[key];\n                }\n            });\n            value = (value.value || '').toString();\n            if (!value.trim()) {\n                return;\n            }\n        }\n\n        if (options.prepared) {\n            // header value is\n            headers.push(key + ': ' + value);\n            return;\n        }\n\n        switch (header.key) {\n            case 'Content-Disposition':\n                structured = libmime.parseHeaderValue(value);\n                if (_self.filename) {\n                    structured.params.filename = _self.filename;\n                }\n                value = libmime.buildHeaderValue(structured);\n                break;\n            case 'Content-Type':\n                structured = libmime.parseHeaderValue(value);\n\n                _self._handleContentType(structured);\n\n                if (structured.value.match(/^text\\/plain\\b/) && typeof _self.content === 'string' && /[\\u0080-\\uFFFF]/.test(_self.content)) {\n                    structured.params.charset = 'utf-8';\n                }\n\n                value = libmime.buildHeaderValue(structured);\n\n                if (_self.filename) {\n                    // add support for non-compliant clients like QQ webmail\n                    // we can't build the value with buildHeaderValue as the value is non standard and\n                    // would be converted to parameter continuation encoding that we do not want\n                    param = this._encodeWords(_self.filename);\n                    if (param !== _self.filename || /[\\s\"=;]/.test(param)) {\n                        // include value in quotes if needed\n                        param = '\"' + param + '\"';\n                    }\n                    value += '; name=' + param;\n                }\n                break;\n            case 'Bcc':\n                if (!_self.keepBcc) {\n                    // skip BCC values\n                    return;\n                }\n                break;\n        }\n\n        value = _self._encodeHeaderValue(key, value);\n\n        // skip empty lines\n        if (!(value || '').toString().trim()) {\n            return;\n        }\n\n        headers.push(libmime.foldLines(key + ': ' + value, 76));\n    }.bind(this));\n\n    return headers.join('\\r\\n');\n};\n\n/**\n * Streams the rfc2822 message from the current node. If this is a root node,\n * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n *\n * @return {String} Compiled message\n */\nMimeNode.prototype.createReadStream = function (options) {\n    options = options || {};\n\n    var outputStream = new PassThrough(options);\n    var transform;\n\n    this.stream(outputStream, options, function (err) {\n        if (err) {\n            outputStream.emit('error', err);\n            return;\n        }\n        outputStream.end();\n    });\n\n    for (var i = 0, len = this._transforms.length; i < len; i++) {\n        transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n        outputStream.once('error', function (err) {\n            transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n    }\n\n    return outputStream;\n};\n\n/**\n * Appends a transform stream object to the transforms list. Final output\n * is passed through this stream before exposing\n *\n * @param {Object} transform Read-Write stream\n */\nMimeNode.prototype.transform = function (transform) {\n    this._transforms.push(transform);\n};\n\nMimeNode.prototype.stream = function (outputStream, options, done) {\n    var _self = this;\n    var transferEncoding = this.getTransferEncoding();\n    var contentStream;\n    var localStream;\n\n    // protect actual callback against multiple triggering\n    var returned = false;\n    var callback = function (err) {\n        if (returned) {\n            return;\n        }\n        returned = true;\n        done(err);\n    };\n\n    // pushes node content\n    function sendContent() {\n        if (_self.content) {\n\n            if (Object.prototype.toString.call(_self.content) === '[object Error]') {\n                // content is already errored\n                return callback(_self.content);\n            }\n\n            if (typeof _self.content.pipe === 'function') {\n                _self.content.removeListener('error', _self._contentErrorHandler);\n                _self._contentErrorHandler = function (err) {\n                    return callback(err);\n                };\n                _self.content.once('error', _self._contentErrorHandler);\n            }\n\n            if (['quoted-printable', 'base64'].indexOf(transferEncoding) >= 0) {\n                contentStream = new(transferEncoding === 'base64' ? libbase64 : libqp).Encoder(options);\n\n                contentStream.pipe(outputStream, {\n                    end: false\n                });\n                contentStream.once('end', finalize);\n                contentStream.once('error', function (err) {\n                    return callback(err);\n                });\n\n                localStream = _self._getStream(_self.content);\n                localStream.pipe(contentStream);\n            } else {\n                // anything that is not QP or Base54 passes as-is\n                localStream = _self._getStream(_self.content);\n                localStream.pipe(outputStream, {\n                    end: false\n                });\n                localStream.once('end', finalize);\n            }\n\n            localStream.once('error', function (err) {\n                return callback(err);\n            });\n\n            return;\n        } else {\n            return setImmediate(finalize);\n        }\n    }\n\n    // for multipart nodes, push child nodes\n    // for content nodes end the stream\n    function finalize() {\n        var childId = 0;\n        var processChildNode = function () {\n            if (childId >= _self.childNodes.length) {\n                outputStream.write('\\r\\n--' + _self.boundary + '--\\r\\n');\n                return callback();\n            }\n            var child = _self.childNodes[childId++];\n            outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + _self.boundary + '\\r\\n');\n            child.stream(outputStream, options, function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                setImmediate(processChildNode);\n            });\n        };\n\n        if (_self.multipart) {\n            setImmediate(processChildNode);\n        } else {\n            return callback();\n        }\n    }\n\n    if (this._raw) {\n        setImmediate(function () {\n            if (Object.prototype.toString.call(_self._raw) === '[object Error]') {\n                // content is already errored\n                return callback(_self._raw);\n            }\n\n            // remove default error handler (if set)\n            if (typeof _self._raw.pipe === 'function') {\n                _self._raw.removeListener('error', _self._contentErrorHandler);\n            }\n\n            var raw = _self._getStream(_self._raw);\n            raw.pipe(outputStream, {\n                end: false\n            });\n            raw.on('error', function (err) {\n                outputStream.emit('error', err);\n            });\n            raw.on('end', finalize);\n        });\n    } else {\n        outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n        setImmediate(sendContent);\n    }\n};\n\n/**\n * Sets envelope to be used instead of the generated one\n *\n * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n */\nMimeNode.prototype.setEnvelope = function (envelope) {\n    var list;\n\n    this._envelope = {\n        from: false,\n        to: []\n    };\n\n    if (envelope.from) {\n        list = [];\n        this._convertAddresses(this._parseAddresses(envelope.from), list);\n        list = list.filter(function (address) {\n            return address && address.address;\n        });\n        if (list.length && list[0]) {\n            this._envelope.from = list[0].address;\n        }\n    }\n    ['to', 'cc', 'bcc'].forEach(function (key) {\n        if (envelope[key]) {\n            this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n        }\n    }.bind(this));\n\n    this._envelope.to = this._envelope.to.map(function (to) {\n        return to.address;\n    }).filter(function (address) {\n        return address;\n    });\n\n    return this;\n};\n\n/**\n * Generates and returns an object with parsed address fields\n *\n * @return {Object} Address object\n */\nMimeNode.prototype.getAddresses = function () {\n    var addresses = {};\n\n    this._headers.forEach(function (header) {\n        var key = header.key.toLowerCase();\n        if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].indexOf(key) >= 0) {\n            if (!Array.isArray(addresses[key])) {\n                addresses[key] = [];\n            }\n\n            this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n        }\n    }.bind(this));\n\n    return addresses;\n};\n\n/**\n * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n *\n * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n */\nMimeNode.prototype.getEnvelope = function () {\n    if (this._envelope) {\n        return this._envelope;\n    }\n\n    var envelope = {\n        from: false,\n        to: []\n    };\n    this._headers.forEach(function (header) {\n        var list = [];\n        if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].indexOf(header.key) >= 0)) {\n            this._convertAddresses(this._parseAddresses(header.value), list);\n            if (list.length && list[0]) {\n                envelope.from = list[0].address;\n            }\n        } else if (['To', 'Cc', 'Bcc'].indexOf(header.key) >= 0) {\n            this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n        }\n    }.bind(this));\n\n    envelope.to = envelope.to.map(function (to) {\n        return to.address;\n    });\n\n    return envelope;\n};\n\n/**\n * Returns Message-Id value. If it does not exist, then creates one\n *\n * @return {String} Message-Id value\n */\nMimeNode.prototype.messageId = function () {\n    var messageId = this.getHeader('Message-ID');\n    // You really should define your own Message-Id field!\n    if (!messageId) {\n        messageId = this._generateMessageId();\n        this.setHeader('Message-ID', messageId);\n    }\n    return messageId;\n};\n\n/**\n * Sets pregenerated content that will be used as the output of this node\n *\n * @param {String|Buffer|Stream} Raw MIME contents\n */\nMimeNode.prototype.setRaw = function (raw) {\n    var _self = this;\n\n    this._raw = raw;\n\n    if (this._raw && typeof this._raw.pipe === 'function') {\n        // pre-stream handler. might be triggered if a stream is set as content\n        // and 'error' fires before anything is done with this stream\n        this._contentErrorHandler = function (err) {\n            _self._raw.removeListener('error', _self._contentErrorHandler);\n            _self._raw = err;\n        };\n        _self._raw.once('error', this._contentErrorHandler);\n    }\n\n    return this;\n};\n\n/////// PRIVATE METHODS\n\n/**\n * Detects and returns handle to a stream related with the content.\n *\n * @param {Mixed} content Node content\n * @returns {Object} Stream object\n */\nMimeNode.prototype._getStream = function (content) {\n    var contentStream;\n\n    if (typeof content.pipe === 'function') {\n        // assume as stream\n        return content;\n    } else if (content && typeof content.path === 'string' && !content.href) {\n        if (this.disableFileAccess) {\n            contentStream = new PassThrough();\n            setImmediate(function () {\n                contentStream.emit('error', new Error('File access rejected for ' + content.path));\n            });\n            return contentStream;\n        }\n        // read file\n        return fs.createReadStream(content.path);\n    } else if (content && typeof content.href === 'string') {\n        if (this.disableUrlAccess) {\n            contentStream = new PassThrough();\n            setImmediate(function () {\n                contentStream.emit('error', new Error('Url access rejected for ' + content.href));\n            });\n            return contentStream;\n        }\n        // fetch URL\n        return fetch(content.href);\n    } else {\n        // pass string or buffer content as a stream\n        contentStream = new PassThrough();\n        setImmediate(function () {\n            contentStream.end(content || '');\n        });\n        return contentStream;\n    }\n};\n\n/**\n * Parses addresses. Takes in a single address or an array or an\n * array of address arrays (eg. To: [[first group], [second group],...])\n *\n * @param {Mixed} addresses Addresses to be parsed\n * @return {Array} An array of address objects\n */\nMimeNode.prototype._parseAddresses = function (addresses) {\n    return [].concat.apply([], [].concat(addresses).map(function (address) {\n        if (address && address.address) {\n            address = this._convertAddresses(address);\n        }\n        return addressparser(address);\n    }.bind(this)));\n};\n\n/**\n * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n *\n * @param {String} key Key to be normalized\n * @return {String} key in Camel-Case form\n */\nMimeNode.prototype._normalizeHeaderKey = function (key) {\n    return (key || '').toString().\n        // no newlines in keys\n    replace(/\\r?\\n|\\r/g, ' ').\n    trim().toLowerCase().\n        // use uppercase words, except MIME\n    replace(/^X\\-SMTPAPI$|^(MIME|DKIM)\\b|^[a-z]|\\-(SPF|FBL|ID|MD5)$|\\-[a-z]/ig,\n            function (c) {\n                return c.toUpperCase();\n            }).\n        // special case\n    replace(/^Content\\-Features$/i, 'Content-features');\n};\n\n/**\n * Checks if the content type is multipart and defines boundary if needed.\n * Doesn't return anything, modifies object argument instead.\n *\n * @param {Object} structured Parsed header value for 'Content-Type' key\n */\nMimeNode.prototype._handleContentType = function (structured) {\n    this.contentType = structured.value.trim().toLowerCase();\n\n    this.multipart = this.contentType.split('/').reduce(function (prev, value) {\n        return prev === 'multipart' ? value : false;\n    });\n\n    if (this.multipart) {\n        this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n    } else {\n        this.boundary = false;\n    }\n};\n\n/**\n * Generates a multipart boundary value\n *\n * @return {String} boundary value\n */\nMimeNode.prototype._generateBoundary = function () {\n    return this.rootNode.boundaryPrefix + '-?=_' + this._nodeId + '-' + this.rootNode.baseBoundary;\n};\n\n/**\n * Encodes a header value for use in the generated rfc2822 email.\n *\n * @param {String} key Header key\n * @param {String} value Header value\n */\nMimeNode.prototype._encodeHeaderValue = function (key, value) {\n    key = this._normalizeHeaderKey(key);\n\n    switch (key) {\n\n        // Structured headers\n        case 'From':\n        case 'Sender':\n        case 'To':\n        case 'Cc':\n        case 'Bcc':\n        case 'Reply-To':\n            return this._convertAddresses(this._parseAddresses(value));\n\n            // values enclosed in <>\n        case 'Message-ID':\n        case 'In-Reply-To':\n        case 'Content-Id':\n            value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n            if (value.charAt(0) !== '<') {\n                value = '<' + value;\n            }\n\n            if (value.charAt(value.length - 1) !== '>') {\n                value = value + '>';\n            }\n            return value;\n\n            // space separated list of values enclosed in <>\n        case 'References':\n            value = [].concat.apply([], [].concat(value || '').map(function (elm) {\n                elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n                return elm.replace(/<[^>]*>/g, function (str) {\n                    return str.replace(/\\s/g, '');\n                }).split(/\\s+/);\n            })).map(function (elm) {\n                if (elm.charAt(0) !== '<') {\n                    elm = '<' + elm;\n                }\n                if (elm.charAt(elm.length - 1) !== '>') {\n                    elm = elm + '>';\n                }\n                return elm;\n            });\n\n            return value.join(' ').trim();\n\n        case 'Date':\n            if (Object.prototype.toString.call(value) === '[object Date]') {\n                return value.toUTCString().replace(/GMT/, '+0000');\n            }\n\n            value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n            return this._encodeWords(value);\n\n        default:\n            value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n            // encodeWords only encodes if needed, otherwise the original string is returned\n            return this._encodeWords(value);\n    }\n};\n\n/**\n * Rebuilds address object using punycode and other adjustments\n *\n * @param {Array} addresses An array of address objects\n * @param {Array} [uniqueList] An array to be populated with addresses\n * @return {String} address string\n */\nMimeNode.prototype._convertAddresses = function (addresses, uniqueList) {\n    var values = [];\n\n    uniqueList = uniqueList || [];\n\n    [].concat(addresses || []).forEach(function (address) {\n        if (address.address) {\n            address.address = address.address.replace(/@.+$/, function (domain) {\n                // usernames are not touched and are kept as is even if these include unicode\n                // domains are punycoded by default\n                // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n                // non-unicode domains are left as is\n                return '@' + punycode.toASCII(domain.substr(1));\n            });\n\n            if (!address.name) {\n                values.push(address.address);\n            } else if (address.name) {\n                values.push(this._encodeAddressName(address.name) + ' <' + address.address + '>');\n            }\n\n            if (address.address) {\n                if (!uniqueList.filter(\n                        function (a) {\n                            return a.address === address.address;\n                        }).length) {\n                    uniqueList.push(address);\n                }\n            }\n        } else if (address.group) {\n            values.push(this._encodeAddressName(address.name) + ':' + (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim() + ';');\n        }\n    }.bind(this));\n\n    return values.join(', ');\n};\n\n/**\n * If needed, mime encodes the name part\n *\n * @param {String} name Name part of an address\n * @returns {String} Mime word encoded string if needed\n */\nMimeNode.prototype._encodeAddressName = function (name) {\n    if (!/^[\\w ']*$/.test(name)) {\n        if (/^[\\x20-\\x7e]*$/.test(name)) {\n            return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n        } else {\n            return libmime.encodeWord(name, this._getTextEncoding(name), 52);\n        }\n    }\n    return name;\n};\n\n/**\n * If needed, mime encodes the name part\n *\n * @param {String} name Name part of an address\n * @returns {String} Mime word encoded string if needed\n */\nMimeNode.prototype._encodeWords = function (value) {\n    return libmime.encodeWords(value, this._getTextEncoding(value), 52);\n};\n\n/**\n * Detects best mime encoding for a text value\n *\n * @param {String} value Value to check for\n * @return {String} either 'Q' or 'B'\n */\nMimeNode.prototype._getTextEncoding = function (value) {\n    value = (value || '').toString();\n\n    var encoding = this.textEncoding;\n    var latinLen;\n    var nonLatinLen;\n\n    if (!encoding) {\n        // count latin alphabet symbols and 8-bit range symbols + control symbols\n        // if there are more latin characters, then use quoted-printable\n        // encoding, otherwise use base64\n        nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length;\n        latinLen = (value.match(/[a-z]/gi) || []).length;\n        // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n        encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n    }\n    return encoding;\n};\n\n/**\n * Generates a message id\n *\n * @return {String} Random Message-ID value\n */\nMimeNode.prototype._generateMessageId = function () {\n    return '<' + [2, 2, 2, 6].reduce(\n            // crux to generate UUID-like random strings\n            function (prev, len) {\n                return prev + '-' + crypto.randomBytes(len).toString('hex');\n            }, crypto.randomBytes(4).toString('hex')) +\n        '@' +\n        // try to use the domain of the FROM address or fallback to server hostname\n        (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() + '>';\n};\n"]},"metadata":{},"sourceType":"script"}