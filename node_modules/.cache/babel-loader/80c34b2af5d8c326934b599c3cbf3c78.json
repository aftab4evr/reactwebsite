{"ast":null,"code":"'use strict';\n\nvar stream = require('stream');\n\nvar util = require('util');\n\nvar Transform = stream.Transform; // expose to the world\n\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  wrap: wrap,\n  Encoder: Encoder,\n  Decoder: Decoder\n};\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\n\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = new Buffer(buffer, 'utf-8');\n  } // usable characters that do not need encoding\n\n\n  var ranges = [// https://tools.ietf.org/html/rfc2045#section-6.7\n  [0x09], // <TAB>\n  [0x0A], // <LF>\n  [0x0D], // <CR>\n  [0x20, 0x3C], // <SP>!\"#$%&'()*+,-./0123456789:;\n  [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n  ];\n  var result = '';\n  var ord;\n\n  for (var i = 0, len = buffer.length; i < len; i++) {\n    ord = buffer[i]; // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n\n    if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n      result += String.fromCharCode(ord);\n      continue;\n    }\n\n    result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n  }\n\n  return result;\n}\n/**\n * Decodes a Quoted-Printable encoded string to a Buffer object\n *\n * @param {String} str Quoted-Printable encoded string\n * @returns {Buffer} Decoded value\n */\n\n\nfunction decode(str) {\n  str = (str || '').toString(). // remove invalid whitespace from the end of lines\n  replace(/[\\t ]+$/gm, ''). // remove soft line breaks\n  replace(/\\=(?:\\r?\\n|$)/g, '');\n  var encodedBytesCount = (str.match(/\\=[\\da-fA-F]{2}/g) || []).length,\n      bufferLength = str.length - encodedBytesCount * 2,\n      chr,\n      hex,\n      buffer = new Buffer(bufferLength),\n      bufferPos = 0;\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    chr = str.charAt(i);\n\n    if (chr === '=' && (hex = str.substr(i + 1, 2)) && /[\\da-fA-F]{2}/.test(hex)) {\n      buffer[bufferPos++] = parseInt(hex, 16);\n      i += 2;\n      continue;\n    }\n\n    buffer[bufferPos++] = chr.charCodeAt(0);\n  }\n\n  return buffer;\n}\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\n\n\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n\n  if (str.length <= lineLength) {\n    return str;\n  }\n\n  var pos = 0,\n      len = str.length,\n      match,\n      code,\n      line,\n      lineMargin = Math.floor(lineLength / 3),\n      result = ''; // insert soft linebreaks where needed\n\n  while (pos < len) {\n    line = str.substr(pos, lineLength);\n\n    if (match = line.match(/\\r\\n/)) {\n      line = line.substr(0, match.index + match[0].length);\n      result += line;\n      pos += line.length;\n      continue;\n    }\n\n    if (line.substr(-1) === '\\n') {\n      // nothing to change here\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (match = line.substr(-lineMargin).match(/\\n.*?$/)) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1));\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t\\.,!\\?][^ \\t\\.,!\\?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1));\n    } else {\n      if (line.match(/\\=[\\da-f]{0,2}$/i)) {\n        // push incomplete encoding sequences to the next line\n        if (match = line.match(/\\=[\\da-f]{0,1}$/i)) {\n          line = line.substr(0, line.length - match[0].length);\n        } // ensure that utf-8 sequences are not split\n\n\n        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/\\=[\\da-f]{2}$/ig))) {\n          code = parseInt(match[0].substr(1, 2), 16);\n\n          if (code < 128) {\n            break;\n          }\n\n          line = line.substr(0, line.length - 3);\n\n          if (code >= 0xC0) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (pos + line.length < len && line.substr(-1) !== '\\n') {\n      if (line.length === lineLength && line.match(/\\=[\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3);\n      } else if (line.length === lineLength) {\n        line = line.substr(0, line.length - 1);\n      }\n\n      pos += line.length;\n      line += '=\\r\\n';\n    } else {\n      pos += line.length;\n    }\n\n    result += line;\n  }\n\n  return result;\n}\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\n\n\nfunction checkRanges(nr, ranges) {\n  for (var i = ranges.length - 1; i >= 0; i--) {\n    if (!ranges[i].length) {\n      continue;\n    }\n\n    if (ranges[i].length === 1 && nr === ranges[i][0]) {\n      return true;\n    }\n\n    if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\n\n\nfunction Encoder(options) {\n  // init Transform\n  this.options = options || {};\n\n  if (this.options.lineLength !== false) {\n    this.options.lineLength = this.options.lineLength || 76;\n  }\n\n  this._curLine = '';\n  this.inputBytes = 0;\n  this.outputBytes = 0;\n  Transform.call(this, this.options);\n}\n\nutil.inherits(Encoder, Transform);\n\nEncoder.prototype._transform = function (chunk, encoding, done) {\n  var qp,\n      _self = this;\n\n  if (encoding !== 'buffer') {\n    chunk = new Buffer(chunk, encoding);\n  }\n\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n\n  this.inputBytes += chunk.length;\n\n  if (this.options.lineLength) {\n    qp = this._curLine + encode(chunk);\n    qp = wrap(qp, this.options.lineLength);\n    qp = qp.replace(/(^|\\n)([^\\n]*)$/, function (match, lineBreak, lastLine) {\n      _self._curLine = lastLine;\n      return lineBreak;\n    });\n\n    if (qp) {\n      this.outputBytes += qp.length;\n      this.push(qp);\n    }\n  } else {\n    qp = encode(chunk);\n    this.outputBytes += qp.length;\n    this.push(qp, 'ascii');\n  }\n\n  done();\n};\n\nEncoder.prototype._flush = function (done) {\n  if (this._curLine) {\n    this.outputBytes += this._curLine.length;\n    this.push(this._curLine, 'ascii');\n  }\n\n  done();\n};\n/**\n * Creates a transform stream for decoding Quoted-Printable encoded strings\n *\n * @constructor\n * @param {Object} options Stream options\n */\n\n\nfunction Decoder(options) {\n  // init Transform\n  this.options = options || {};\n  this._curLine = '';\n  this.inputBytes = 0;\n  this.outputBytes = 0;\n  Transform.call(this, this.options);\n}\n\nutil.inherits(Decoder, Transform);\n\nDecoder.prototype._transform = function (chunk, encoding, done) {\n  var qp,\n      buf,\n      _self = this;\n\n  chunk = chunk.toString('ascii');\n\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n\n  this.inputBytes += chunk.length;\n  qp = this._curLine + chunk;\n  this._curLine = '';\n  qp = qp.replace(/=[^\\n]?$/, function (lastLine) {\n    _self._curLine = lastLine;\n    return '';\n  });\n\n  if (qp) {\n    buf = decode(qp);\n    this.outputBytes += buf.length;\n    this.push(buf);\n  }\n\n  done();\n};\n\nDecoder.prototype._flush = function (done) {\n  var qp, buf;\n\n  if (this._curLine) {\n    buf = decode(this._curLine);\n    this.outputBytes += buf.length;\n    this.push(buf);\n  }\n\n  done();\n};","map":{"version":3,"sources":["/Users/aftab/Desktop/React/reactlivewebsite-master/node_modules/libqp/lib/libqp.js"],"names":["stream","require","util","Transform","module","exports","encode","decode","wrap","Encoder","Decoder","buffer","Buffer","ranges","result","ord","i","len","length","checkRanges","String","fromCharCode","toString","toUpperCase","str","replace","encodedBytesCount","match","bufferLength","chr","hex","bufferPos","charAt","substr","test","parseInt","charCodeAt","lineLength","pos","code","line","lineMargin","Math","floor","index","nr","options","_curLine","inputBytes","outputBytes","call","inherits","prototype","_transform","chunk","encoding","done","qp","_self","lineBreak","lastLine","push","_flush","buf"],"mappings":"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","sourcesContent":["'use strict';\n\nvar stream = require('stream');\nvar util = require('util');\nvar Transform = stream.Transform;\n\n// expose to the world\nmodule.exports = {\n    encode: encode,\n    decode: decode,\n    wrap: wrap,\n    Encoder: Encoder,\n    Decoder: Decoder\n};\n\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\nfunction encode(buffer) {\n    if (typeof buffer === 'string') {\n        buffer = new Buffer(buffer, 'utf-8');\n    }\n\n    // usable characters that do not need encoding\n    var ranges = [\n        // https://tools.ietf.org/html/rfc2045#section-6.7\n        [0x09], // <TAB>\n        [0x0A], // <LF>\n        [0x0D], // <CR>\n        [0x20, 0x3C], // <SP>!\"#$%&'()*+,-./0123456789:;\n        [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ];\n    var result = '';\n    var ord;\n\n    for (var i = 0, len = buffer.length; i < len; i++) {\n        ord = buffer[i];\n        // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n            result += String.fromCharCode(ord);\n            continue;\n        }\n        result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n    }\n\n    return result;\n}\n\n/**\n * Decodes a Quoted-Printable encoded string to a Buffer object\n *\n * @param {String} str Quoted-Printable encoded string\n * @returns {Buffer} Decoded value\n */\nfunction decode(str) {\n    str = (str || '').toString().\n        // remove invalid whitespace from the end of lines\n    replace(/[\\t ]+$/gm, '').\n        // remove soft line breaks\n    replace(/\\=(?:\\r?\\n|$)/g, '');\n\n    var encodedBytesCount = (str.match(/\\=[\\da-fA-F]{2}/g) || []).length,\n        bufferLength = str.length - encodedBytesCount * 2,\n        chr, hex,\n        buffer = new Buffer(bufferLength),\n        bufferPos = 0;\n\n    for (var i = 0, len = str.length; i < len; i++) {\n        chr = str.charAt(i);\n        if (chr === '=' && (hex = str.substr(i + 1, 2)) && /[\\da-fA-F]{2}/.test(hex)) {\n            buffer[bufferPos++] = parseInt(hex, 16);\n            i += 2;\n            continue;\n        }\n        buffer[bufferPos++] = chr.charCodeAt(0);\n    }\n\n    return buffer;\n}\n\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\nfunction wrap(str, lineLength) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n\n    if (str.length <= lineLength) {\n        return str;\n    }\n\n    var pos = 0,\n        len = str.length,\n        match, code, line,\n        lineMargin = Math.floor(lineLength / 3),\n        result = '';\n\n    // insert soft linebreaks where needed\n    while (pos < len) {\n        line = str.substr(pos, lineLength);\n        if ((match = line.match(/\\r\\n/))) {\n            line = line.substr(0, match.index + match[0].length);\n            result += line;\n            pos += line.length;\n            continue;\n        }\n\n        if (line.substr(-1) === '\\n') {\n            // nothing to change here\n            result += line;\n            pos += line.length;\n            continue;\n        } else if ((match = line.substr(-lineMargin).match(/\\n.*?$/))) {\n            // truncate to nearest line break\n            line = line.substr(0, line.length - (match[0].length - 1));\n            result += line;\n            pos += line.length;\n            continue;\n        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t\\.,!\\?][^ \\t\\.,!\\?]*$/))) {\n            // truncate to nearest space\n            line = line.substr(0, line.length - (match[0].length - 1));\n        } else {\n            if (line.match(/\\=[\\da-f]{0,2}$/i)) {\n\n                // push incomplete encoding sequences to the next line\n                if ((match = line.match(/\\=[\\da-f]{0,1}$/i))) {\n                    line = line.substr(0, line.length - match[0].length);\n                }\n\n                // ensure that utf-8 sequences are not split\n                while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/\\=[\\da-f]{2}$/ig))) {\n                    code = parseInt(match[0].substr(1, 2), 16);\n                    if (code < 128) {\n                        break;\n                    }\n\n                    line = line.substr(0, line.length - 3);\n\n                    if (code >= 0xC0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (pos + line.length < len && line.substr(-1) !== '\\n') {\n            if (line.length === lineLength && line.match(/\\=[\\da-f]{2}$/i)) {\n                line = line.substr(0, line.length - 3);\n            } else if (line.length === lineLength) {\n                line = line.substr(0, line.length - 1);\n            }\n            pos += line.length;\n            line += '=\\r\\n';\n        } else {\n            pos += line.length;\n        }\n\n        result += line;\n    }\n\n    return result;\n}\n\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\nfunction checkRanges(nr, ranges) {\n    for (var i = ranges.length - 1; i >= 0; i--) {\n        if (!ranges[i].length) {\n            continue;\n        }\n        if (ranges[i].length === 1 && nr === ranges[i][0]) {\n            return true;\n        }\n        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\nfunction Encoder(options) {\n    // init Transform\n    this.options = options || {};\n\n    if (this.options.lineLength !== false) {\n        this.options.lineLength = this.options.lineLength || 76;\n    }\n\n    this._curLine = '';\n\n    this.inputBytes = 0;\n    this.outputBytes = 0;\n\n    Transform.call(this, this.options);\n}\nutil.inherits(Encoder, Transform);\n\nEncoder.prototype._transform = function(chunk, encoding, done) {\n    var qp, _self = this;\n\n    if (encoding !== 'buffer') {\n        chunk = new Buffer(chunk, encoding);\n    }\n\n    if (!chunk || !chunk.length) {\n        return done();\n    }\n\n    this.inputBytes += chunk.length;\n\n    if (this.options.lineLength) {\n        qp = this._curLine + encode(chunk);\n        qp = wrap(qp, this.options.lineLength);\n        qp = qp.replace(/(^|\\n)([^\\n]*)$/, function(match, lineBreak, lastLine) {\n            _self._curLine = lastLine;\n            return lineBreak;\n        });\n\n        if (qp) {\n            this.outputBytes += qp.length;\n            this.push(qp);\n        }\n\n    } else {\n        qp = encode(chunk);\n        this.outputBytes += qp.length;\n        this.push(qp, 'ascii');\n    }\n\n    done();\n};\n\nEncoder.prototype._flush = function(done) {\n    if (this._curLine) {\n        this.outputBytes += this._curLine.length;\n        this.push(this._curLine, 'ascii');\n    }\n    done();\n};\n\n/**\n * Creates a transform stream for decoding Quoted-Printable encoded strings\n *\n * @constructor\n * @param {Object} options Stream options\n */\nfunction Decoder(options) {\n    // init Transform\n    this.options = options || {};\n    this._curLine = '';\n\n    this.inputBytes = 0;\n    this.outputBytes = 0;\n\n    Transform.call(this, this.options);\n}\nutil.inherits(Decoder, Transform);\n\nDecoder.prototype._transform = function(chunk, encoding, done) {\n    var qp, buf, _self = this;\n\n    chunk = chunk.toString('ascii');\n\n    if (!chunk || !chunk.length) {\n        return done();\n    }\n\n    this.inputBytes += chunk.length;\n\n    qp = (this._curLine + chunk);\n    this._curLine = '';\n    qp = qp.replace(/=[^\\n]?$/, function(lastLine) {\n        _self._curLine = lastLine;\n        return '';\n    });\n\n    if (qp) {\n        buf = decode(qp);\n        this.outputBytes += buf.length;\n        this.push(buf);\n    }\n\n    done();\n};\n\nDecoder.prototype._flush = function(done) {\n    var qp, buf;\n    if (this._curLine) {\n        buf = decode(this._curLine);\n        this.outputBytes += buf.length;\n        this.push(buf);\n    }\n    done();\n};"]},"metadata":{},"sourceType":"script"}