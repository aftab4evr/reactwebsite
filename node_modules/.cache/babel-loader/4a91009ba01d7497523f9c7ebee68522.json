{"ast":null,"code":"'use strict';\n\nvar libcharset = require('./charset');\n\nvar libbase64 = require('libbase64');\n\nvar libqp = require('libqp');\n\nvar mimetypes = require('./mimetypes');\n\nvar libmime = module.exports = {\n  /**\n   * Checks if a value is plaintext string (uses only printable 7bit chars)\n   *\n   * @param {String} value String to be tested\n   * @returns {Boolean} true if it is a plaintext string\n   */\n  isPlainText: function (value) {\n    if (typeof value !== 'string' || /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\u0080-\\uFFFF]/.test(value)) {\n      return false;\n    } else {\n      return true;\n    }\n  },\n\n  /**\n   * Checks if a multi line string containes lines longer than the selected value.\n   *\n   * Useful when detecting if a mail message needs any processing at all â€“\n   * if only plaintext characters are used and lines are short, then there is\n   * no need to encode the values in any way. If the value is plaintext but has\n   * longer lines then allowed, then use format=flowed\n   *\n   * @param {Number} lineLength Max line length to check for\n   * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars\n   */\n  hasLongerLines: function (str, lineLength) {\n    return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);\n  },\n\n  /**\n   * Decodes a string from a format=flowed soft wrapping.\n   *\n   * @param {String} str Plaintext string with format=flowed to decode\n   * @param {Boolean} [delSp] If true, delete leading spaces (delsp=yes)\n   * @return {String} Mime decoded string\n   */\n  decodeFlowed: function (str, delSp) {\n    str = (str || '').toString();\n    return str.split(/\\r?\\n/). // remove soft linebreaks\n    // soft linebreaks are added after space symbols\n    reduce(function (previousValue, currentValue, index) {\n      var body = previousValue;\n\n      if (delSp) {\n        // delsp adds spaces to text to be able to fold it\n        // these spaces can be removed once the text is unfolded\n        body = body.replace(/[ ]+$/, '');\n      }\n\n      if (/ $/.test(previousValue) && !/(^|\\n)\\-\\- $/.test(previousValue) || index === 1) {\n        return body + currentValue;\n      } else {\n        return body + '\\n' + currentValue;\n      }\n    }). // remove whitespace stuffing\n    // http://tools.ietf.org/html/rfc3676#section-4.4\n    replace(/^ /gm, '');\n  },\n\n  /**\n   * Adds soft line breaks to content marked with format=flowed to\n   * ensure that no line in the message is never longer than lineLength\n   *\n   * @param {String} str Plaintext string that requires wrapping\n   * @param {Number} [lineLength=76] Maximum length of a line\n   * @return {String} String with forced line breaks\n   */\n  encodeFlowed: function (str, lineLength) {\n    lineLength = lineLength || 76;\n    var flowed = [];\n    str.split(/\\r?\\n/).forEach(function (line) {\n      flowed.push(libmime.foldLines(line. // space stuffing http://tools.ietf.org/html/rfc3676#section-4.2\n      replace(/^( |From|>)/igm, ' $1'), lineLength, true));\n    });\n    return flowed.join('\\r\\n');\n  },\n\n  /**\n   * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n   * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n   * @return {String} Single or several mime words joined together\n   */\n  encodeWord: function (data, mimeWordEncoding, maxLength) {\n    mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);\n    maxLength = maxLength || 0;\n    var encodedStr,\n        toCharset = 'UTF-8',\n        i,\n        len,\n        parts,\n        lpart,\n        chr;\n\n    if (maxLength && maxLength > 7 + toCharset.length) {\n      maxLength -= 7 + toCharset.length;\n    }\n\n    if (mimeWordEncoding === 'Q') {\n      // https://tools.ietf.org/html/rfc2047#section-5 rule (3)\n      encodedStr = libqp.encode(data).replace(/[^a-z0-9!*+\\-\\/=]/ig, function (chr) {\n        var ord = chr.charCodeAt(0).toString(16).toUpperCase();\n\n        if (chr === ' ') {\n          return '_';\n        } else {\n          return '=' + (ord.length === 1 ? '0' + ord : ord);\n        }\n      });\n    } else if (mimeWordEncoding === 'B') {\n      encodedStr = typeof data === 'string' ? data : libbase64.encode(data);\n      maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;\n    }\n\n    if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : libbase64.encode(data)).length > maxLength) {\n      if (mimeWordEncoding === 'Q') {\n        encodedStr = splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n      } else {\n        // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences\n        parts = [];\n        lpart = '';\n\n        for (i = 0, len = encodedStr.length; i < len; i++) {\n          chr = encodedStr.charAt(i); // check if we can add this character to the existing string\n          // without breaking byte length limit\n\n          if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {\n            lpart += chr;\n          } else {\n            // we hit the length limit, so push the existing string and start over\n            parts.push(libbase64.encode(lpart));\n            lpart = chr;\n          }\n        }\n\n        if (lpart) {\n          parts.push(libbase64.encode(lpart));\n        }\n\n        if (parts.length > 1) {\n          encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n        } else {\n          encodedStr = parts.join('');\n        }\n      }\n    } else if (mimeWordEncoding === 'B') {\n      encodedStr = libbase64.encode(data);\n    }\n\n    return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');\n  },\n\n  /**\n   * Decode a complete mime word encoded string\n   *\n   * @param {String} str Mime word encoded string\n   * @return {String} Decoded unicode string\n   */\n  decodeWord: function (str) {\n    str = (str || '').toString().trim();\n    var fromCharset, encoding, match;\n    match = str.match(/^\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?([^\\?]+)\\?\\=$/i);\n\n    if (!match) {\n      return str;\n    } // RFC2231 added language tag to the encoding\n    // see: https://tools.ietf.org/html/rfc2231#section-5\n    // this implementation silently ignores this tag\n\n\n    fromCharset = match[1].split('*').shift();\n    encoding = (match[2] || 'Q').toString().toUpperCase();\n    str = (match[3] || '').replace(/_/g, ' ').replace(/ $/, '=20');\n\n    if (encoding === 'B') {\n      return libcharset.decode(libbase64.decode(str), fromCharset);\n    } else if (encoding === 'Q') {\n      return libcharset.decode(libqp.decode(str), fromCharset);\n    } else {\n      return str;\n    }\n  },\n\n  /**\n   * Finds word sequences with non ascii text and converts these to mime words\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n   * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n   * @param {String} [fromCharset='UTF-8'] Source sharacter set\n   * @return {String} String with possible mime words\n   */\n  encodeWords: function (data, mimeWordEncoding, maxLength, fromCharset) {\n    if (!fromCharset && typeof maxLength === 'string' && !maxLength.match(/^[0-9]+$/)) {\n      fromCharset = maxLength;\n      maxLength = undefined;\n    }\n\n    maxLength = maxLength || 0;\n    var decodedValue = libcharset.decode(libcharset.convert(data || '', fromCharset)),\n        encodedValue;\n    encodedValue = decodedValue.replace(/([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g, function (match) {\n      return match.length ? libmime.encodeWord(match, mimeWordEncoding || 'Q', maxLength) : '';\n    });\n    return encodedValue;\n  },\n\n  /**\n   * Decode a string that might include one or several mime words\n   *\n   * @param {String} str String including some mime words that will be encoded\n   * @return {String} Decoded unicode string\n   */\n  decodeWords: function (str) {\n    return (str || '').toString(). // find base64 words that can be joined\n    replace(/(=\\?([^?]+)\\?[Bb]\\?[^?]+[^^=]\\?=)\\s*(?==\\?([^?]+)\\?[Bb]\\?[^?]+\\?=)/g, function (match, left, chLeft, chRight) {\n      // only mark to b64 chunks to be joined if charsets match\n      if (libcharset.normalizeCharset(chLeft || '').toLowerCase().trim() === libcharset.normalizeCharset(chRight || '').toLowerCase().trim()) {\n        // set a joiner marker\n        return left + '__\\x00JOIN\\x00__';\n      }\n\n      return match;\n    }). // join base64 encoded words\n    replace(/(\\?=)?__\\x00JOIN\\x00__(=\\?([^?]+)\\?[Bb]\\?)?/g, ''). // remove spaces between mime encoded words\n    replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)/g, '$1'). // decode words\n    replace(/\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?[^\\?]+\\?\\=/g, function (mimeWord) {\n      return libmime.decodeWord(mimeWord);\n    });\n  },\n\n  /**\n   * Splits a string by :\n   * The result is not mime word decoded, you need to do your own decoding based\n   * on the rules for the specific header key\n   *\n   * @param {String} headerLine Single header line, might include linebreaks as well if folded\n   * @return {Object} And object of {key, value}\n   */\n  decodeHeader: function (headerLine) {\n    var line = (headerLine || '').toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim(),\n        match = line.match(/^\\s*([^:]+):(.*)$/),\n        key = (match && match[1] || '').trim().toLowerCase(),\n        value = (match && match[2] || '').trim();\n    return {\n      key: key,\n      value: value\n    };\n  },\n\n  /**\n   * Parses a block of header lines. Does not decode mime words as every\n   * header might have its own rules (eg. formatted email addresses and such)\n   *\n   * @param {String} headers Headers string\n   * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n   */\n  decodeHeaders: function (headers) {\n    var lines = headers.split(/\\r?\\n|\\r/),\n        headersObj = {},\n        header,\n        i,\n        len;\n\n    for (i = lines.length - 1; i >= 0; i--) {\n      if (i && lines[i].match(/^\\s/)) {\n        lines[i - 1] += '\\r\\n' + lines[i];\n        lines.splice(i, 1);\n      }\n    }\n\n    for (i = 0, len = lines.length; i < len; i++) {\n      header = libmime.decodeHeader(lines[i]);\n\n      if (!headersObj[header.key]) {\n        headersObj[header.key] = [header.value];\n      } else {\n        headersObj[header.key].push(header.value);\n      }\n    }\n\n    return headersObj;\n  },\n\n  /**\n   * Joins parsed header value together as 'value; param1=value1; param2=value2'\n   *\n   * @param {Object} structured Parsed header value\n   * @return {String} joined header value\n   */\n  buildHeaderValue: function (structured) {\n    var paramsArray = [];\n    Object.keys(structured.params || {}).forEach(function (param) {\n      // filename might include unicode characters so it is a special case\n      var value = structured.params[param];\n\n      if (!libmime.isPlainText(value) || value.length >= 75) {\n        libmime.buildHeaderParam(param, value, 50).forEach(function (encodedParam) {\n          if (!/[\\s\"\\\\;\\/=]|^[\\-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {\n            paramsArray.push(encodedParam.key + '=' + encodedParam.value);\n          } else {\n            paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));\n          }\n        });\n      } else if (/[\\s'\"\\\\;\\/=]|^\\-/.test(value)) {\n        paramsArray.push(param + '=' + JSON.stringify(value));\n      } else {\n        paramsArray.push(param + '=' + value);\n      }\n    }.bind(this));\n    return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');\n  },\n\n  /**\n   * Parses a header value with key=value arguments into a structured\n   * object.\n   *\n   *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n   *   {\n   *     'value': 'text/plain',\n   *     'params': {\n   *       'charset': 'UTF-8'\n   *     }\n   *   }\n   *\n   * @param {String} str Header value\n   * @return {Object} Header value as a parsed structure\n   */\n  parseHeaderValue: function (str) {\n    var response = {\n      value: false,\n      params: {}\n    },\n        key = false,\n        value = '',\n        type = 'value',\n        quote = false,\n        escaped = false,\n        chr;\n\n    for (var i = 0, len = str.length; i < len; i++) {\n      chr = str.charAt(i);\n\n      if (type === 'key') {\n        if (chr === '=') {\n          key = value.trim().toLowerCase();\n          type = 'value';\n          value = '';\n          continue;\n        }\n\n        value += chr;\n      } else {\n        if (escaped) {\n          value += chr;\n        } else if (chr === '\\\\') {\n          escaped = true;\n          continue;\n        } else if (quote && chr === quote) {\n          quote = false;\n        } else if (!quote && chr === '\"') {\n          quote = chr;\n        } else if (!quote && chr === ';') {\n          if (key === false) {\n            response.value = value.trim();\n          } else {\n            response.params[key] = value.trim();\n          }\n\n          type = 'key';\n          value = '';\n        } else {\n          value += chr;\n        }\n\n        escaped = false;\n      }\n    }\n\n    if (type === 'value') {\n      if (key === false) {\n        response.value = value.trim();\n      } else {\n        response.params[key] = value.trim();\n      }\n    } else if (value.trim()) {\n      response.params[value.trim().toLowerCase()] = '';\n    } // handle parameter value continuations\n    // https://tools.ietf.org/html/rfc2231#section-3\n    // preprocess values\n\n\n    Object.keys(response.params).forEach(function (key) {\n      var actualKey, nr, match, value;\n\n      if (match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/)) {\n        actualKey = key.substr(0, match.index);\n        nr = Number(match[2] || match[3]) || 0;\n\n        if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n          response.params[actualKey] = {\n            charset: false,\n            values: []\n          };\n        }\n\n        value = response.params[key];\n\n        if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n          response.params[actualKey].charset = match[1] || 'iso-8859-1';\n          value = match[2];\n        }\n\n        response.params[actualKey].values[nr] = value; // remove the old reference\n\n        delete response.params[key];\n      }\n    }); // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n\n    Object.keys(response.params).forEach(function (key) {\n      var value;\n\n      if (response.params[key] && Array.isArray(response.params[key].values)) {\n        value = response.params[key].values.map(function (val) {\n          return val || '';\n        }).join('');\n\n        if (response.params[key].charset) {\n          // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n          response.params[key] = '=?' + response.params[key].charset + '?Q?' + value. // fix invalidly encoded chars\n          replace(/[=\\?_\\s]/g, function (s) {\n            var c = s.charCodeAt(0).toString(16);\n\n            if (s === ' ') {\n              return '_';\n            } else {\n              return '%' + (c.length < 2 ? '0' : '') + c;\n            }\n          }). // change from urlencoding to percent encoding\n          replace(/%/g, '=') + '?=';\n        } else {\n          response.params[key] = value;\n        }\n      }\n    }.bind(this));\n    return response;\n  },\n\n  /**\n   * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n   * Useful for splitting long parameter values.\n   *\n   * For example\n   *      title=\"unicode string\"\n   * becomes\n   *     title*0*=utf-8''unicode\n   *     title*1*=%20string\n   *\n   * @param {String|Buffer} data String to be encoded\n   * @param {Number} [maxLength=50] Max length for generated chunks\n   * @param {String} [fromCharset='UTF-8'] Source sharacter set\n   * @return {Array} A list of encoded keys and headers\n   */\n  buildHeaderParam: function (key, data, maxLength, fromCharset) {\n    var list = [];\n    var encodedStr = typeof data === 'string' ? data : libmime.decode(data, fromCharset);\n    var encodedStrArr;\n    var chr, ord;\n    var line;\n    var startPos = 0;\n    var isEncoded = false;\n    var i, len;\n    maxLength = maxLength || 50; // process ascii only text\n\n    if (libmime.isPlainText(data)) {\n      // check if conversion is even needed\n      if (encodedStr.length <= maxLength) {\n        return [{\n          key: key,\n          value: encodedStr\n        }];\n      }\n\n      encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n        list.push({\n          line: str\n        });\n        return '';\n      });\n\n      if (encodedStr) {\n        list.push({\n          line: encodedStr\n        });\n      }\n    } else {\n      if (/[\\uD800-\\uDBFF]/.test(encodedStr)) {\n        // string containts surrogate pairs, so normalize it to an array of bytes\n        encodedStrArr = [];\n\n        for (i = 0, len = encodedStr.length; i < len; i++) {\n          chr = encodedStr.charAt(i);\n          ord = chr.charCodeAt(0);\n\n          if (ord >= 0xD800 && ord <= 0xDBFF && i < len - 1) {\n            chr += encodedStr.charAt(i + 1);\n            encodedStrArr.push(chr);\n            i++;\n          } else {\n            encodedStrArr.push(chr);\n          }\n        }\n\n        encodedStr = encodedStrArr;\n      } // first line includes the charset and language info and needs to be encoded\n      // even if it does not contain any unicode characters\n\n\n      line = 'utf-8\\'\\'';\n      isEncoded = true;\n      startPos = 0; // process text with unicode or special chars\n\n      for (i = 0, len = encodedStr.length; i < len; i++) {\n        chr = encodedStr[i];\n\n        if (isEncoded) {\n          chr = safeEncodeURIComponent(chr);\n        } else {\n          // try to urlencode current char\n          chr = chr === ' ' ? chr : safeEncodeURIComponent(chr); // By default it is not required to encode a line, the need\n          // only appears when the string contains unicode or special chars\n          // in this case we start processing the line over and encode all chars\n\n          if (chr !== encodedStr[i]) {\n            // Check if it is even possible to add the encoded char to the line\n            // If not, there is no reason to use this line, just push it to the list\n            // and start a new line with the char that needs encoding\n            if ((safeEncodeURIComponent(line) + chr).length >= maxLength) {\n              list.push({\n                line: line,\n                encoded: isEncoded\n              });\n              line = '';\n              startPos = i - 1;\n            } else {\n              isEncoded = true;\n              i = startPos;\n              line = '';\n              continue;\n            }\n          }\n        } // if the line is already too long, push it to the list and start a new one\n\n\n        if ((line + chr).length >= maxLength) {\n          list.push({\n            line: line,\n            encoded: isEncoded\n          });\n          line = chr = encodedStr[i] === ' ' ? ' ' : safeEncodeURIComponent(encodedStr[i]);\n\n          if (chr === encodedStr[i]) {\n            isEncoded = false;\n            startPos = i - 1;\n          } else {\n            isEncoded = true;\n          }\n        } else {\n          line += chr;\n        }\n      }\n\n      if (line) {\n        list.push({\n          line: line,\n          encoded: isEncoded\n        });\n      }\n    }\n\n    return list.map(function (item, i) {\n      return {\n        // encoded lines: {name}*{part}*\n        // unencoded lines: {name}*{part}\n        // if any line needs to be encoded then the first line (part==0) is always encoded\n        key: key + '*' + i + (item.encoded ? '*' : ''),\n        value: item.line\n      };\n    });\n  },\n\n  /**\n   * Returns file extension for a content type string. If no suitable extensions\n   * are found, 'bin' is used as the default extension\n   *\n   * @param {String} mimeType Content type to be checked for\n   * @return {String} File extension\n   */\n  detectExtension: function (mimeType) {\n    mimeType = (mimeType || '').toString().toLowerCase().replace(/\\s/g, '');\n\n    if (!(mimeType in mimetypes.list)) {\n      return 'bin';\n    }\n\n    if (typeof mimetypes.list[mimeType] === 'string') {\n      return mimetypes.list[mimeType];\n    }\n\n    var mimeParts = mimeType.split('/'); // search for name match\n\n    for (var i = 0, len = mimetypes.list[mimeType].length; i < len; i++) {\n      if (mimeParts[1] === mimetypes.list[mimeType][i]) {\n        return mimetypes.list[mimeType][i];\n      }\n    } // use the first one\n\n\n    return mimetypes.list[mimeType][0] !== '*' ? mimetypes.list[mimeType][0] : 'bin';\n  },\n\n  /**\n   * Returns content type for a file extension. If no suitable content types\n   * are found, 'application/octet-stream' is used as the default content type\n   *\n   * @param {String} extension Extension to be checked for\n   * @return {String} File extension\n   */\n  detectMimeType: function (extension) {\n    extension = (extension || '').toString().toLowerCase().replace(/\\s/g, '').replace(/^\\./g, '').split('.').pop();\n\n    if (!(extension in mimetypes.extensions)) {\n      return 'application/octet-stream';\n    }\n\n    if (typeof mimetypes.extensions[extension] === 'string') {\n      return mimetypes.extensions[extension];\n    }\n\n    var mimeParts; // search for name match\n\n    for (var i = 0, len = mimetypes.extensions[extension].length; i < len; i++) {\n      mimeParts = mimetypes.extensions[extension][i].split('/');\n\n      if (mimeParts[1] === extension) {\n        return mimetypes.extensions[extension][i];\n      }\n    } // use the first one\n\n\n    return mimetypes.extensions[extension][0];\n  },\n\n  /**\n   * Folds long lines, useful for folding header lines (afterSpace=false) and\n   * flowed text (afterSpace=true)\n   *\n   * @param {String} str String to be folded\n   * @param {Number} [lineLength=76] Maximum length of a line\n   * @param {Boolean} afterSpace If true, leave a space in th end of a line\n   * @return {String} String with folded lines\n   */\n  foldLines: function (str, lineLength, afterSpace) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n    var pos = 0,\n        len = str.length,\n        result = '',\n        line,\n        match;\n\n    while (pos < len) {\n      line = str.substr(pos, lineLength);\n\n      if (line.length < lineLength) {\n        result += line;\n        break;\n      }\n\n      if (match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/)) {\n        line = match[0];\n        result += line;\n        pos += line.length;\n        continue;\n      } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n        line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n      } else if (match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/)) {\n        line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n      }\n\n      result += line;\n      pos += line.length;\n\n      if (pos < len) {\n        result += '\\r\\n';\n      }\n    }\n\n    return result;\n  }\n};\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\n\nfunction splitMimeEncodedString(str, maxlen) {\n  var curLine,\n      match,\n      chr,\n      done,\n      lines = []; // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n\n  maxlen = Math.max(maxlen || 0, 12);\n\n  while (str.length) {\n    curLine = str.substr(0, maxlen); // move incomplete escaped char back to main\n\n    if (match = curLine.match(/\\=[0-9A-F]?$/i)) {\n      curLine = curLine.substr(0, match.index);\n    }\n\n    done = false;\n\n    while (!done) {\n      done = true; // check if not middle of a unicode char sequence\n\n      if (match = str.substr(curLine.length).match(/^\\=([0-9A-F]{2})/i)) {\n        chr = parseInt(match[1], 16); // invalid sequence, move one char back anc recheck\n\n        if (chr < 0xC2 && chr > 0x7F) {\n          curLine = curLine.substr(0, curLine.length - 3);\n          done = false;\n        }\n      }\n    }\n\n    if (curLine.length) {\n      lines.push(curLine);\n    }\n\n    str = str.substr(curLine.length);\n  }\n\n  return lines;\n}\n\nfunction encodeURICharComponent(chr) {\n  var i, len, ord;\n  var res = '';\n  ord = chr.charCodeAt(0).toString(16).toUpperCase();\n\n  if (ord.length % 2) {\n    ord = '0' + ord;\n  }\n\n  if (ord.length > 2) {\n    for (i = 0, len = ord.length / 2; i < len; i++) {\n      res += '%' + ord.substr(i, 2);\n    }\n  } else {\n    res += '%' + ord;\n  }\n\n  return res;\n}\n\nfunction safeEncodeURIComponent(str) {\n  str = (str || '').toString();\n\n  try {\n    // might throw if we try to encode invalid sequences, eg. partial emoji\n    str = encodeURIComponent(str);\n  } catch (E) {\n    // should never run\n    return str.replace(/[^\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]+/g, '');\n  } // ensure chars that are not handled by encodeURICompent are converted as well\n\n\n  return str.replace(/[\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]/g, encodeURICharComponent);\n}","map":{"version":3,"sources":["/Users/aftab/Desktop/React/reactlivewebsite-master/node_modules/buildmail/node_modules/libmime/lib/libmime.js"],"names":["libcharset","require","libbase64","libqp","mimetypes","libmime","module","exports","isPlainText","value","test","hasLongerLines","str","lineLength","RegExp","decodeFlowed","delSp","toString","split","reduce","previousValue","currentValue","index","body","replace","encodeFlowed","flowed","forEach","line","push","foldLines","join","encodeWord","data","mimeWordEncoding","maxLength","toUpperCase","trim","charAt","encodedStr","toCharset","i","len","parts","lpart","chr","length","encode","ord","charCodeAt","Math","max","splitMimeEncodedString","Buffer","byteLength","substr","decodeWord","fromCharset","encoding","match","shift","decode","encodeWords","undefined","decodedValue","convert","encodedValue","decodeWords","left","chLeft","chRight","normalizeCharset","toLowerCase","mimeWord","decodeHeader","headerLine","key","decodeHeaders","headers","lines","headersObj","header","splice","buildHeaderValue","structured","paramsArray","Object","keys","params","param","buildHeaderParam","encodedParam","JSON","stringify","bind","parseHeaderValue","response","type","quote","escaped","actualKey","nr","Number","charset","values","Array","isArray","map","val","s","c","list","encodedStrArr","startPos","isEncoded","safeEncodeURIComponent","encoded","item","detectExtension","mimeType","mimeParts","detectMimeType","extension","pop","extensions","afterSpace","pos","result","maxlen","curLine","done","parseInt","encodeURICharComponent","res","encodeURIComponent","E"],"mappings":"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","sourcesContent":["'use strict';\n\nvar libcharset = require('./charset');\nvar libbase64 = require('libbase64');\nvar libqp = require('libqp');\nvar mimetypes = require('./mimetypes');\n\nvar libmime = module.exports = {\n\n    /**\n     * Checks if a value is plaintext string (uses only printable 7bit chars)\n     *\n     * @param {String} value String to be tested\n     * @returns {Boolean} true if it is a plaintext string\n     */\n    isPlainText: function (value) {\n        if (typeof value !== 'string' || /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\u0080-\\uFFFF]/.test(value)) {\n            return false;\n        } else {\n            return true;\n        }\n    },\n\n    /**\n     * Checks if a multi line string containes lines longer than the selected value.\n     *\n     * Useful when detecting if a mail message needs any processing at all â€“\n     * if only plaintext characters are used and lines are short, then there is\n     * no need to encode the values in any way. If the value is plaintext but has\n     * longer lines then allowed, then use format=flowed\n     *\n     * @param {Number} lineLength Max line length to check for\n     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars\n     */\n    hasLongerLines: function (str, lineLength) {\n        return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);\n    },\n\n    /**\n     * Decodes a string from a format=flowed soft wrapping.\n     *\n     * @param {String} str Plaintext string with format=flowed to decode\n     * @param {Boolean} [delSp] If true, delete leading spaces (delsp=yes)\n     * @return {String} Mime decoded string\n     */\n    decodeFlowed: function (str, delSp) {\n        str = (str || '').toString();\n\n        return str.\n        split(/\\r?\\n/).\n            // remove soft linebreaks\n            // soft linebreaks are added after space symbols\n        reduce(\n                function (previousValue, currentValue, index) {\n                    var body = previousValue;\n                    if (delSp) {\n                        // delsp adds spaces to text to be able to fold it\n                        // these spaces can be removed once the text is unfolded\n                        body = body.replace(/[ ]+$/, '');\n                    }\n                    if (/ $/.test(previousValue) && !/(^|\\n)\\-\\- $/.test(previousValue) || index === 1) {\n                        return body + currentValue;\n                    } else {\n                        return body + '\\n' + currentValue;\n                    }\n                }\n            ).\n            // remove whitespace stuffing\n            // http://tools.ietf.org/html/rfc3676#section-4.4\n        replace(/^ /gm, '');\n    },\n\n    /**\n     * Adds soft line breaks to content marked with format=flowed to\n     * ensure that no line in the message is never longer than lineLength\n     *\n     * @param {String} str Plaintext string that requires wrapping\n     * @param {Number} [lineLength=76] Maximum length of a line\n     * @return {String} String with forced line breaks\n     */\n    encodeFlowed: function (str, lineLength) {\n        lineLength = lineLength || 76;\n\n        var flowed = [];\n        str.split(/\\r?\\n/).forEach(function (line) {\n            flowed.push(libmime.foldLines(line.\n                // space stuffing http://tools.ietf.org/html/rfc3676#section-4.2\n                replace(/^( |From|>)/igm, ' $1'),\n                lineLength, true));\n        });\n        return flowed.join('\\r\\n');\n    },\n\n    /**\n     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n     * @return {String} Single or several mime words joined together\n     */\n    encodeWord: function (data, mimeWordEncoding, maxLength) {\n        mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);\n        maxLength = maxLength || 0;\n\n        var encodedStr,\n            toCharset = 'UTF-8',\n            i, len, parts, lpart, chr;\n\n        if (maxLength && maxLength > 7 + toCharset.length) {\n            maxLength -= (7 + toCharset.length);\n        }\n\n        if (mimeWordEncoding === 'Q') {\n            // https://tools.ietf.org/html/rfc2047#section-5 rule (3)\n            encodedStr = libqp.encode(data).replace(/[^a-z0-9!*+\\-\\/=]/ig, function (chr) {\n                var ord = chr.charCodeAt(0).toString(16).toUpperCase();\n                if (chr === ' ') {\n                    return '_';\n                } else {\n                    return '=' + (ord.length === 1 ? '0' + ord : ord);\n                }\n            });\n        } else if (mimeWordEncoding === 'B') {\n            encodedStr = typeof data === 'string' ? data : libbase64.encode(data);\n            maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;\n        }\n\n        if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : libbase64.encode(data)).length > maxLength) {\n            if (mimeWordEncoding === 'Q') {\n                encodedStr = splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n            } else {\n                // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences\n                parts = [];\n                lpart = '';\n                for (i = 0, len = encodedStr.length; i < len; i++) {\n                    chr = encodedStr.charAt(i);\n                    // check if we can add this character to the existing string\n                    // without breaking byte length limit\n                    if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {\n                        lpart += chr;\n                    } else {\n                        // we hit the length limit, so push the existing string and start over\n                        parts.push(libbase64.encode(lpart));\n                        lpart = chr;\n                    }\n                }\n                if (lpart) {\n                    parts.push(libbase64.encode(lpart));\n                }\n\n                if (parts.length > 1) {\n                    encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n                } else {\n                    encodedStr = parts.join('');\n                }\n            }\n        } else if (mimeWordEncoding === 'B') {\n            encodedStr = libbase64.encode(data);\n        }\n\n        return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');\n    },\n\n    /**\n     * Decode a complete mime word encoded string\n     *\n     * @param {String} str Mime word encoded string\n     * @return {String} Decoded unicode string\n     */\n    decodeWord: function (str) {\n        str = (str || '').toString().trim();\n\n        var fromCharset, encoding, match;\n\n        match = str.match(/^\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?([^\\?]+)\\?\\=$/i);\n        if (!match) {\n            return str;\n        }\n\n        // RFC2231 added language tag to the encoding\n        // see: https://tools.ietf.org/html/rfc2231#section-5\n        // this implementation silently ignores this tag\n        fromCharset = match[1].split('*').shift();\n\n        encoding = (match[2] || 'Q').toString().toUpperCase();\n        str = (match[3] || '').replace(/_/g, ' ').replace(/ $/, '=20');\n\n        if (encoding === 'B') {\n            return libcharset.decode(libbase64.decode(str), fromCharset);\n        } else if (encoding === 'Q') {\n            return libcharset.decode(libqp.decode(str), fromCharset);\n        } else {\n            return str;\n        }\n    },\n\n    /**\n     * Finds word sequences with non ascii text and converts these to mime words\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n     * @param {String} [fromCharset='UTF-8'] Source sharacter set\n     * @return {String} String with possible mime words\n     */\n    encodeWords: function (data, mimeWordEncoding, maxLength, fromCharset) {\n        if (!fromCharset && typeof maxLength === 'string' && !maxLength.match(/^[0-9]+$/)) {\n            fromCharset = maxLength;\n            maxLength = undefined;\n        }\n\n        maxLength = maxLength || 0;\n\n        var decodedValue = libcharset.decode(libcharset.convert((data || ''), fromCharset)),\n            encodedValue;\n\n        encodedValue = decodedValue.replace(/([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g, function (match) {\n            return match.length ? libmime.encodeWord(match, mimeWordEncoding || 'Q', maxLength) : '';\n        });\n\n        return encodedValue;\n    },\n\n    /**\n     * Decode a string that might include one or several mime words\n     *\n     * @param {String} str String including some mime words that will be encoded\n     * @return {String} Decoded unicode string\n     */\n    decodeWords: function (str) {\n        return (str || '').toString().\n\n        // find base64 words that can be joined\n        replace(/(=\\?([^?]+)\\?[Bb]\\?[^?]+[^^=]\\?=)\\s*(?==\\?([^?]+)\\?[Bb]\\?[^?]+\\?=)/g,\n            function (match, left, chLeft, chRight) {\n                // only mark to b64 chunks to be joined if charsets match\n                if (libcharset.normalizeCharset(chLeft || '').toLowerCase().trim() === libcharset.normalizeCharset(chRight || '').toLowerCase().trim()) {\n                    // set a joiner marker\n                    return left + '__\\x00JOIN\\x00__';\n                }\n                return match;\n            }).\n\n        // join base64 encoded words\n        replace(/(\\?=)?__\\x00JOIN\\x00__(=\\?([^?]+)\\?[Bb]\\?)?/g, '').\n\n        // remove spaces between mime encoded words\n        replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)/g, '$1').\n\n        // decode words\n        replace(/\\=\\?([\\w_\\-\\*]+)\\?([QqBb])\\?[^\\?]+\\?\\=/g, function (mimeWord) {\n            return libmime.decodeWord(mimeWord);\n        });\n    },\n\n    /**\n     * Splits a string by :\n     * The result is not mime word decoded, you need to do your own decoding based\n     * on the rules for the specific header key\n     *\n     * @param {String} headerLine Single header line, might include linebreaks as well if folded\n     * @return {Object} And object of {key, value}\n     */\n    decodeHeader: function (headerLine) {\n        var line = (headerLine || '').toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim(),\n            match = line.match(/^\\s*([^:]+):(.*)$/),\n            key = (match && match[1] || '').trim().toLowerCase(),\n            value = (match && match[2] || '').trim();\n\n        return {\n            key: key,\n            value: value\n        };\n    },\n\n    /**\n     * Parses a block of header lines. Does not decode mime words as every\n     * header might have its own rules (eg. formatted email addresses and such)\n     *\n     * @param {String} headers Headers string\n     * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n     */\n    decodeHeaders: function (headers) {\n        var lines = headers.split(/\\r?\\n|\\r/),\n            headersObj = {},\n            header,\n            i, len;\n\n        for (i = lines.length - 1; i >= 0; i--) {\n            if (i && lines[i].match(/^\\s/)) {\n                lines[i - 1] += '\\r\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n\n        for (i = 0, len = lines.length; i < len; i++) {\n            header = libmime.decodeHeader(lines[i]);\n            if (!headersObj[header.key]) {\n                headersObj[header.key] = [header.value];\n            } else {\n                headersObj[header.key].push(header.value);\n            }\n        }\n\n        return headersObj;\n    },\n\n    /**\n     * Joins parsed header value together as 'value; param1=value1; param2=value2'\n     *\n     * @param {Object} structured Parsed header value\n     * @return {String} joined header value\n     */\n    buildHeaderValue: function (structured) {\n        var paramsArray = [];\n\n        Object.keys(structured.params || {}).forEach(function (param) {\n            // filename might include unicode characters so it is a special case\n            var value = structured.params[param];\n            if (!libmime.isPlainText(value) || value.length >= 75) {\n                libmime.buildHeaderParam(param, value, 50).forEach(function (encodedParam) {\n                    if (!/[\\s\"\\\\;\\/=]|^[\\-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {\n                        paramsArray.push(encodedParam.key + '=' + encodedParam.value);\n                    } else {\n                        paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));\n                    }\n                });\n            } else if (/[\\s'\"\\\\;\\/=]|^\\-/.test(value)) {\n                paramsArray.push(param + '=' + JSON.stringify(value));\n            } else {\n                paramsArray.push(param + '=' + value);\n            }\n        }.bind(this));\n\n        return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');\n    },\n\n    /**\n     * Parses a header value with key=value arguments into a structured\n     * object.\n     *\n     *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n     *   {\n     *     'value': 'text/plain',\n     *     'params': {\n     *       'charset': 'UTF-8'\n     *     }\n     *   }\n     *\n     * @param {String} str Header value\n     * @return {Object} Header value as a parsed structure\n     */\n    parseHeaderValue: function (str) {\n        var response = {\n                value: false,\n                params: {}\n            },\n            key = false,\n            value = '',\n            type = 'value',\n            quote = false,\n            escaped = false,\n            chr;\n\n        for (var i = 0, len = str.length; i < len; i++) {\n            chr = str.charAt(i);\n            if (type === 'key') {\n                if (chr === '=') {\n                    key = value.trim().toLowerCase();\n                    type = 'value';\n                    value = '';\n                    continue;\n                }\n                value += chr;\n            } else {\n                if (escaped) {\n                    value += chr;\n                } else if (chr === '\\\\') {\n                    escaped = true;\n                    continue;\n                } else if (quote && chr === quote) {\n                    quote = false;\n                } else if (!quote && chr === '\"') {\n                    quote = chr;\n                } else if (!quote && chr === ';') {\n                    if (key === false) {\n                        response.value = value.trim();\n                    } else {\n                        response.params[key] = value.trim();\n                    }\n                    type = 'key';\n                    value = '';\n                } else {\n                    value += chr;\n                }\n                escaped = false;\n\n            }\n        }\n\n        if (type === 'value') {\n            if (key === false) {\n                response.value = value.trim();\n            } else {\n                response.params[key] = value.trim();\n            }\n        } else if (value.trim()) {\n            response.params[value.trim().toLowerCase()] = '';\n        }\n\n        // handle parameter value continuations\n        // https://tools.ietf.org/html/rfc2231#section-3\n\n        // preprocess values\n        Object.keys(response.params).forEach(function (key) {\n            var actualKey, nr, match, value;\n            if ((match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/))) {\n                actualKey = key.substr(0, match.index);\n                nr = Number(match[2] || match[3]) || 0;\n\n                if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n                    response.params[actualKey] = {\n                        charset: false,\n                        values: []\n                    };\n                }\n\n                value = response.params[key];\n\n                if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n                    response.params[actualKey].charset = match[1] || 'iso-8859-1';\n                    value = match[2];\n                }\n\n                response.params[actualKey].values[nr] = value;\n\n                // remove the old reference\n                delete response.params[key];\n            }\n        });\n\n        // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n        Object.keys(response.params).forEach(function (key) {\n            var value;\n            if (response.params[key] && Array.isArray(response.params[key].values)) {\n                value = response.params[key].values.map(function (val) {\n                    return val || '';\n                }).join('');\n\n                if (response.params[key].charset) {\n                    // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n                    response.params[key] = '=?' +\n                        response.params[key].charset +\n                        '?Q?' +\n                        value.\n                        // fix invalidly encoded chars\n                    replace(/[=\\?_\\s]/g,\n                            function (s) {\n                                var c = s.charCodeAt(0).toString(16);\n                                if (s === ' ') {\n                                    return '_';\n                                } else {\n                                    return '%' + (c.length < 2 ? '0' : '') + c;\n                                }\n                            }\n                        ).\n                        // change from urlencoding to percent encoding\n                    replace(/%/g, '=') +\n                        '?=';\n                } else {\n                    response.params[key] = value;\n                }\n            }\n        }.bind(this));\n\n        return response;\n    },\n\n    /**\n     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n     * Useful for splitting long parameter values.\n     *\n     * For example\n     *      title=\"unicode string\"\n     * becomes\n     *     title*0*=utf-8''unicode\n     *     title*1*=%20string\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {Number} [maxLength=50] Max length for generated chunks\n     * @param {String} [fromCharset='UTF-8'] Source sharacter set\n     * @return {Array} A list of encoded keys and headers\n     */\n    buildHeaderParam: function (key, data, maxLength, fromCharset) {\n        var list = [];\n        var encodedStr = typeof data === 'string' ? data : libmime.decode(data, fromCharset);\n        var encodedStrArr;\n        var chr, ord;\n        var line;\n        var startPos = 0;\n        var isEncoded = false;\n        var i, len;\n\n        maxLength = maxLength || 50;\n\n        // process ascii only text\n        if (libmime.isPlainText(data)) {\n\n            // check if conversion is even needed\n            if (encodedStr.length <= maxLength) {\n                return [{\n                    key: key,\n                    value: encodedStr\n                }];\n            }\n\n            encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n                list.push({\n                    line: str\n                });\n                return '';\n            });\n\n            if (encodedStr) {\n                list.push({\n                    line: encodedStr\n                });\n            }\n\n        } else {\n\n            if (/[\\uD800-\\uDBFF]/.test(encodedStr)) {\n                // string containts surrogate pairs, so normalize it to an array of bytes\n                encodedStrArr = [];\n                for (i = 0, len = encodedStr.length; i < len; i++) {\n                    chr = encodedStr.charAt(i);\n                    ord = chr.charCodeAt(0);\n                    if (ord >= 0xD800 && ord <= 0xDBFF && i < len - 1) {\n                        chr += encodedStr.charAt(i + 1);\n                        encodedStrArr.push(chr);\n                        i++;\n                    } else {\n                        encodedStrArr.push(chr);\n                    }\n                }\n                encodedStr = encodedStrArr;\n            }\n\n            // first line includes the charset and language info and needs to be encoded\n            // even if it does not contain any unicode characters\n            line = 'utf-8\\'\\'';\n            isEncoded = true;\n            startPos = 0;\n\n            // process text with unicode or special chars\n            for (i = 0, len = encodedStr.length; i < len; i++) {\n\n                chr = encodedStr[i];\n\n                if (isEncoded) {\n                    chr = safeEncodeURIComponent(chr);\n                } else {\n                    // try to urlencode current char\n                    chr = chr === ' ' ? chr : safeEncodeURIComponent(chr);\n                    // By default it is not required to encode a line, the need\n                    // only appears when the string contains unicode or special chars\n                    // in this case we start processing the line over and encode all chars\n                    if (chr !== encodedStr[i]) {\n                        // Check if it is even possible to add the encoded char to the line\n                        // If not, there is no reason to use this line, just push it to the list\n                        // and start a new line with the char that needs encoding\n                        if ((safeEncodeURIComponent(line) + chr).length >= maxLength) {\n                            list.push({\n                                line: line,\n                                encoded: isEncoded\n                            });\n                            line = '';\n                            startPos = i - 1;\n                        } else {\n                            isEncoded = true;\n                            i = startPos;\n                            line = '';\n                            continue;\n                        }\n                    }\n                }\n\n                // if the line is already too long, push it to the list and start a new one\n                if ((line + chr).length >= maxLength) {\n                    list.push({\n                        line: line,\n                        encoded: isEncoded\n                    });\n                    line = chr = encodedStr[i] === ' ' ? ' ' : safeEncodeURIComponent(encodedStr[i]);\n                    if (chr === encodedStr[i]) {\n                        isEncoded = false;\n                        startPos = i - 1;\n                    } else {\n                        isEncoded = true;\n                    }\n                } else {\n                    line += chr;\n                }\n            }\n\n            if (line) {\n                list.push({\n                    line: line,\n                    encoded: isEncoded\n                });\n            }\n        }\n\n        return list.map(function (item, i) {\n            return {\n                // encoded lines: {name}*{part}*\n                // unencoded lines: {name}*{part}\n                // if any line needs to be encoded then the first line (part==0) is always encoded\n                key: key + '*' + i + (item.encoded ? '*' : ''),\n                value: item.line\n            };\n        });\n    },\n\n\n    /**\n     * Returns file extension for a content type string. If no suitable extensions\n     * are found, 'bin' is used as the default extension\n     *\n     * @param {String} mimeType Content type to be checked for\n     * @return {String} File extension\n     */\n    detectExtension: function (mimeType) {\n        mimeType = (mimeType || '').toString().toLowerCase().replace(/\\s/g, '');\n        if (!(mimeType in mimetypes.list)) {\n            return 'bin';\n        }\n\n        if (typeof mimetypes.list[mimeType] === 'string') {\n            return mimetypes.list[mimeType];\n        }\n\n        var mimeParts = mimeType.split('/');\n\n        // search for name match\n        for (var i = 0, len = mimetypes.list[mimeType].length; i < len; i++) {\n            if (mimeParts[1] === mimetypes.list[mimeType][i]) {\n                return mimetypes.list[mimeType][i];\n            }\n        }\n\n        // use the first one\n        return mimetypes.list[mimeType][0] !== '*' ? mimetypes.list[mimeType][0] : 'bin';\n    },\n\n    /**\n     * Returns content type for a file extension. If no suitable content types\n     * are found, 'application/octet-stream' is used as the default content type\n     *\n     * @param {String} extension Extension to be checked for\n     * @return {String} File extension\n     */\n    detectMimeType: function (extension) {\n        extension = (extension || '').toString().toLowerCase().replace(/\\s/g, '').replace(/^\\./g, '').split('.').pop();\n\n        if (!(extension in mimetypes.extensions)) {\n            return 'application/octet-stream';\n        }\n\n        if (typeof mimetypes.extensions[extension] === 'string') {\n            return mimetypes.extensions[extension];\n        }\n\n        var mimeParts;\n\n        // search for name match\n        for (var i = 0, len = mimetypes.extensions[extension].length; i < len; i++) {\n            mimeParts = mimetypes.extensions[extension][i].split('/');\n            if (mimeParts[1] === extension) {\n                return mimetypes.extensions[extension][i];\n            }\n        }\n\n        // use the first one\n        return mimetypes.extensions[extension][0];\n    },\n\n    /**\n     * Folds long lines, useful for folding header lines (afterSpace=false) and\n     * flowed text (afterSpace=true)\n     *\n     * @param {String} str String to be folded\n     * @param {Number} [lineLength=76] Maximum length of a line\n     * @param {Boolean} afterSpace If true, leave a space in th end of a line\n     * @return {String} String with folded lines\n     */\n    foldLines: function (str, lineLength, afterSpace) {\n        str = (str || '').toString();\n        lineLength = lineLength || 76;\n\n        var pos = 0,\n            len = str.length,\n            result = '',\n            line, match;\n\n        while (pos < len) {\n            line = str.substr(pos, lineLength);\n            if (line.length < lineLength) {\n                result += line;\n                break;\n            }\n            if ((match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/))) {\n                line = match[0];\n                result += line;\n                pos += line.length;\n                continue;\n            } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n            } else if ((match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/))) {\n                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n            }\n\n            result += line;\n            pos += line.length;\n            if (pos < len) {\n                result += '\\r\\n';\n            }\n        }\n\n        return result;\n    }\n};\n\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\nfunction splitMimeEncodedString(str, maxlen) {\n    var curLine, match, chr, done,\n        lines = [];\n\n    // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n    maxlen = Math.max(maxlen || 0, 12);\n\n    while (str.length) {\n        curLine = str.substr(0, maxlen);\n\n        // move incomplete escaped char back to main\n        if ((match = curLine.match(/\\=[0-9A-F]?$/i))) {\n            curLine = curLine.substr(0, match.index);\n        }\n\n        done = false;\n        while (!done) {\n            done = true;\n            // check if not middle of a unicode char sequence\n            if ((match = str.substr(curLine.length).match(/^\\=([0-9A-F]{2})/i))) {\n                chr = parseInt(match[1], 16);\n                // invalid sequence, move one char back anc recheck\n                if (chr < 0xC2 && chr > 0x7F) {\n                    curLine = curLine.substr(0, curLine.length - 3);\n                    done = false;\n                }\n            }\n        }\n\n        if (curLine.length) {\n            lines.push(curLine);\n        }\n        str = str.substr(curLine.length);\n    }\n\n    return lines;\n}\n\nfunction encodeURICharComponent(chr) {\n    var i, len, ord;\n    var res = '';\n\n    ord = chr.charCodeAt(0).toString(16).toUpperCase();\n    if (ord.length % 2) {\n        ord = '0' + ord;\n    }\n    if (ord.length > 2) {\n        for (i = 0, len = ord.length / 2; i < len; i++) {\n            res += '%' + ord.substr(i, 2);\n        }\n    } else {\n        res += '%' + ord;\n    }\n\n    return res;\n}\n\nfunction safeEncodeURIComponent(str) {\n    str = (str || '').toString();\n\n    try {\n        // might throw if we try to encode invalid sequences, eg. partial emoji\n        str = encodeURIComponent(str);\n    } catch (E) {\n        // should never run\n        return str.replace(/[^\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]+/g, '');\n    }\n\n    // ensure chars that are not handled by encodeURICompent are converted as well\n    return str.replace(/[\\x00-\\x1F *'()<>@,;:\\\\\"\\[\\]?=\\u007F-\\uFFFF]/g, encodeURICharComponent);\n}\n"]},"metadata":{},"sourceType":"script"}