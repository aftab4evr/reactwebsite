{"ast":null,"code":"'use strict';\n\nvar stream = require('stream');\n\nvar util = require('util');\n\nvar Transform = stream.Transform; // expose to the world\n\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  wrap: wrap,\n  Encoder: Encoder,\n  Decoder: Decoder\n};\n/**\n * Encodes a Buffer into a base64 encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} base64 encoded string\n */\n\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = new Buffer(buffer, 'utf-8');\n  }\n\n  return buffer.toString('base64');\n}\n/**\n * Decodes a base64 encoded string to a Buffer object\n *\n * @param {String} str base64 encoded string\n * @returns {Buffer} Decoded value\n */\n\n\nfunction decode(str) {\n  str = str || '';\n  return new Buffer(str, 'base64');\n}\n/**\n * Adds soft line breaks to a base64 string\n *\n * @param {String} str base64 encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped base64 encoded string\n */\n\n\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n\n  if (str.length <= lineLength) {\n    return str;\n  }\n\n  return str.replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\\r\\n').trim();\n}\n/**\n * Creates a transform stream for encoding data to base64 encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\n\n\nfunction Encoder(options) {\n  // init Transform\n  this.options = options || {};\n\n  if (this.options.lineLength !== false) {\n    this.options.lineLength = this.options.lineLength || 76;\n  }\n\n  this._curLine = '';\n  this._remainingBytes = false;\n  this.inputBytes = 0;\n  this.outputBytes = 0;\n  Transform.call(this, this.options);\n}\n\nutil.inherits(Encoder, Transform);\n\nEncoder.prototype._transform = function (chunk, encoding, done) {\n  var b64,\n      _self = this;\n\n  if (encoding !== 'buffer') {\n    chunk = new Buffer(chunk, encoding);\n  }\n\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n\n  this.inputBytes += chunk.length;\n\n  if (this._remainingBytes && this._remainingBytes.length) {\n    chunk = Buffer.concat([this._remainingBytes, chunk]);\n    this._remainingBytes = false;\n  }\n\n  if (chunk.length % 3) {\n    this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);\n    chunk = chunk.slice(0, chunk.length - chunk.length % 3);\n  } else {\n    this._remainingBytes = false;\n  }\n\n  b64 = this._curLine + encode(chunk);\n\n  if (this.options.lineLength) {\n    b64 = wrap(b64, this.options.lineLength);\n    b64 = b64.replace(/(^|\\n)([^\\n]*)$/, function (match, lineBreak, lastLine) {\n      _self._curLine = lastLine;\n      return lineBreak;\n    });\n  }\n\n  if (b64) {\n    this.outputBytes += b64.length;\n    this.push(b64);\n  }\n\n  done();\n};\n\nEncoder.prototype._flush = function (done) {\n  if (this._remainingBytes && this._remainingBytes.length) {\n    this._curLine += encode(this._remainingBytes);\n  }\n\n  if (this._curLine) {\n    this._curLine = wrap(this._curLine, this.options.lineLength);\n    this.outputBytes += this._curLine.length;\n    this.push(this._curLine, 'ascii');\n    this._curLine = '';\n  }\n\n  done();\n};\n/**\n * Creates a transform stream for decoding base64 encoded strings\n *\n * @constructor\n * @param {Object} options Stream options\n */\n\n\nfunction Decoder(options) {\n  // init Transform\n  this.options = options || {};\n  this._curLine = '';\n  this.inputBytes = 0;\n  this.outputBytes = 0;\n  Transform.call(this, this.options);\n}\n\nutil.inherits(Decoder, Transform);\n\nDecoder.prototype._transform = function (chunk, encoding, done) {\n  var b64, buf;\n  chunk = chunk.toString('ascii');\n\n  if (!chunk || !chunk.length) {\n    return done();\n  }\n\n  this.inputBytes += chunk.length;\n  b64 = this._curLine + chunk;\n  this._curLine = '';\n  b64 = b64.replace(/[^a-zA-Z0-9+\\/=]/g, '');\n\n  if (b64.length % 4) {\n    this._curLine = b64.substr(-b64.length % 4);\n\n    if (this._curLine.length == b64.length) {\n      b64 = '';\n    } else {\n      b64 = b64.substr(0, this._curLine.length);\n    }\n  }\n\n  if (b64) {\n    buf = decode(b64);\n    this.outputBytes += buf.length;\n    this.push(buf);\n  }\n\n  done();\n};\n\nDecoder.prototype._flush = function (done) {\n  var b64, buf;\n\n  if (this._curLine) {\n    buf = decode(this._curLine);\n    this.outputBytes += buf.length;\n    this.push(buf);\n    this._curLine = '';\n  }\n\n  done();\n};","map":{"version":3,"sources":["/Users/aftab/Desktop/React/reactlivewebsite-master/node_modules/libbase64/lib/libbase64.js"],"names":["stream","require","util","Transform","module","exports","encode","decode","wrap","Encoder","Decoder","buffer","Buffer","toString","str","lineLength","length","replace","RegExp","trim","options","_curLine","_remainingBytes","inputBytes","outputBytes","call","inherits","prototype","_transform","chunk","encoding","done","b64","_self","concat","slice","match","lineBreak","lastLine","push","_flush","buf","substr"],"mappings":"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","sourcesContent":["'use strict';\n\nvar stream = require('stream');\nvar util = require('util');\nvar Transform = stream.Transform;\n\n// expose to the world\nmodule.exports = {\n    encode: encode,\n    decode: decode,\n    wrap: wrap,\n    Encoder: Encoder,\n    Decoder: Decoder\n};\n\n/**\n * Encodes a Buffer into a base64 encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} base64 encoded string\n */\nfunction encode(buffer) {\n    if (typeof buffer === 'string') {\n        buffer = new Buffer(buffer, 'utf-8');\n    }\n\n    return buffer.toString('base64');\n}\n\n/**\n * Decodes a base64 encoded string to a Buffer object\n *\n * @param {String} str base64 encoded string\n * @returns {Buffer} Decoded value\n */\nfunction decode(str) {\n    str = (str || '');\n    return new Buffer(str, 'base64');\n}\n\n/**\n * Adds soft line breaks to a base64 string\n *\n * @param {String} str base64 encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped base64 encoded string\n */\nfunction wrap(str, lineLength) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n\n    if (str.length <= lineLength) {\n        return str;\n    }\n\n    return str.replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\\r\\n').trim();\n}\n\n/**\n * Creates a transform stream for encoding data to base64 encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\nfunction Encoder(options) {\n    // init Transform\n    this.options = options || {};\n\n    if (this.options.lineLength !== false) {\n        this.options.lineLength = this.options.lineLength || 76;\n    }\n\n    this._curLine = '';\n    this._remainingBytes = false;\n\n    this.inputBytes = 0;\n    this.outputBytes = 0;\n\n    Transform.call(this, this.options);\n}\nutil.inherits(Encoder, Transform);\n\nEncoder.prototype._transform = function(chunk, encoding, done) {\n    var b64, _self = this;\n\n    if (encoding !== 'buffer') {\n        chunk = new Buffer(chunk, encoding);\n    }\n\n    if (!chunk || !chunk.length) {\n        return done();\n    }\n\n    this.inputBytes += chunk.length;\n\n    if (this._remainingBytes && this._remainingBytes.length) {\n        chunk = Buffer.concat([this._remainingBytes, chunk]);\n        this._remainingBytes = false;\n    }\n\n    if (chunk.length % 3) {\n        this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);\n        chunk = chunk.slice(0, chunk.length - chunk.length % 3);\n    } else {\n        this._remainingBytes = false;\n    }\n\n    b64 = this._curLine + encode(chunk);\n\n    if (this.options.lineLength) {\n        b64 = wrap(b64, this.options.lineLength);\n        b64 = b64.replace(/(^|\\n)([^\\n]*)$/, function(match, lineBreak, lastLine) {\n            _self._curLine = lastLine;\n            return lineBreak;\n        });\n    }\n\n    if (b64) {\n        this.outputBytes += b64.length;\n        this.push(b64);\n    }\n\n    done();\n};\n\nEncoder.prototype._flush = function(done) {\n    if (this._remainingBytes && this._remainingBytes.length) {\n        this._curLine += encode(this._remainingBytes);\n    }\n    if (this._curLine) {\n        this._curLine = wrap(this._curLine, this.options.lineLength);\n        this.outputBytes += this._curLine.length;\n        this.push(this._curLine, 'ascii');\n        this._curLine = '';\n    }\n    done();\n};\n\n/**\n * Creates a transform stream for decoding base64 encoded strings\n *\n * @constructor\n * @param {Object} options Stream options\n */\nfunction Decoder(options) {\n    // init Transform\n    this.options = options || {};\n    this._curLine = '';\n\n    this.inputBytes = 0;\n    this.outputBytes = 0;\n\n    Transform.call(this, this.options);\n}\nutil.inherits(Decoder, Transform);\n\nDecoder.prototype._transform = function(chunk, encoding, done) {\n    var b64, buf;\n\n    chunk = chunk.toString('ascii');\n\n    if (!chunk || !chunk.length) {\n        return done();\n    }\n\n    this.inputBytes += chunk.length;\n\n    b64 = (this._curLine + chunk);\n    this._curLine = '';\n\n    b64 = b64.replace(/[^a-zA-Z0-9+\\/=]/g, '');\n\n    if (b64.length % 4) {\n        this._curLine = b64.substr(-b64.length % 4);\n        if (this._curLine.length == b64.length) {\n            b64 = '';\n        } else {\n            b64 = b64.substr(0, this._curLine.length);\n        }\n    }\n\n    if (b64) {\n        buf = decode(b64);\n        this.outputBytes += buf.length;\n        this.push(buf);\n    }\n\n    done();\n};\n\nDecoder.prototype._flush = function(done) {\n    var b64, buf;\n    if (this._curLine) {\n        buf = decode(this._curLine);\n        this.outputBytes += buf.length;\n        this.push(buf);\n        this._curLine = '';\n    }\n    done();\n};"]},"metadata":{},"sourceType":"script"}